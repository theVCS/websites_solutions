{
  "boilerplate": {
    "prefix": "boilerplate code",
    "body": [
      "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long int\r\n#define pii pair<int, int>\r\n#define REP(i, a, b) for (int i = a; i <= b; i++)\r\n#define RREP(i, a, b) for (int i = a; i >= b; i--)\r\n#define endl \"\\n\"\r\n#define all(x) (x).begin(), (x).end()\r\n#define pi 3.141592653589793238\r\n\r\n#define maxN 1000001\r\n#define INF 1000000000\r\n#define mod 1000000007\r\n#define printd(x) cout << fixed << setprecision(10) << x\r\n// int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\r\n// int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\r\n// int dx[] = {-1, 0, 1, 0, 1, -1, 1, -1};\r\n// int dy[] = {0, -1, 0, 1, -1, -1, 1, 1};\r\n\r\nvoid solve()\r\n{\r\n\t$2\r\n}\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\r\n\t// freopen(\"input.txt\",\"r\",stdin);\r\n\t// freopen(\"output.txt\",\"w\",stdout);\r\n\r\n\tint t = 1;\r\n\r\n\t// cin >> t;\r\n\r\n\tREP(tc, 1, t)\r\n\t{\r\n\t\t// cout<<\"Case \"<<tc<<\":\"<<endl;\r\n\t\tsolve();\r\n\t}\r\n\r\n\treturn 0;\r\n}"
    ],
    "description": "this is a boiler plate"
  },
  "FenwickTree": {
    "prefix": "FenwickTree",
    "body": [
      "template <class T>\r\nclass FenwickTree\r\n{\r\n\tint n, LOGN;\r\n\tvector<T> BIT;\r\n\r\npublic:\r\n\tFenwickTree() {}\r\n\r\n\tFenwickTree(int N)\r\n\t{\r\n\t\tLOGN = log2(N);\r\n\t\tn = N;\r\n\t\tBIT.assign(n + 1, 0);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tLOGN = log2(N);\r\n\t\tn = N;\r\n\t\tBIT.assign(n + 1, 0);\r\n\t}\r\n\r\n\tT query(int index)\r\n\t{\r\n\t\tT q = 0;\r\n\r\n\t\twhile (index > 0)\r\n\t\t{\r\n\t\t\tq += BIT[index];\r\n\t\t\tindex -= (index & -index);\r\n\t\t}\r\n\r\n\t\treturn q;\r\n\t}\r\n\r\n\tvoid update(int index, T val)\r\n\t{\r\n\t\twhile (index <= n)\r\n\t\t{\r\n\t\t\tBIT[index] += val;\r\n\t\t\tindex += (index & -index);\r\n\t\t}\r\n\t}\r\n\r\n\tT query(int l, int r)\r\n\t{\r\n\t\treturn query(r) - query(l - 1);\r\n\t}\r\n\r\n\tvoid update(int l, int r, T val)\r\n\t{\r\n\t\tupdate(l, val);\r\n\t\tupdate(r + 1, -val);\r\n\t}\r\n\r\n\tint lowerBound(T val)\r\n\t{\r\n\t\t// will find the lower bound index of val in BIT if monotonically increasing\r\n\t\t// https://codeforces.com/blog/entry/61364\r\n\r\n\t\tT q = 0;\r\n\t\tint pos = 0;\r\n\r\n\t\tfor (int i = LOGN; i >= 0; i--)\r\n\t\t{\r\n\t\t\tif (pos + (1 << i) <= n && q + BIT[pos + (1 << i)] < val)\r\n\t\t\t{\r\n\t\t\t\tq += BIT[pos + (1 << i)];\r\n\t\t\t\tpos += (1 << i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn pos + 1;\r\n\t}\r\n};"
    ],
    "description": "FenwickTree"
  },
  "FenwickTree2D": {
    "prefix": "FenwickTree2D",
    "body": [
      "template <class T>\r\nclass FenwickTree2D\r\n{\r\n\tint n, m;\r\n\tvector<vector<T>> BIT;\r\n\r\npublic:\r\n\tFenwickTree2D() {}\r\n\r\n\tFenwickTree2D(int N, int M)\r\n\t{\r\n\t\tn = N;\r\n\t\tm = M;\r\n\t\tBIT.resize(n + 1);\r\n\r\n\t\tfor (vector<T> &vec : BIT)\r\n\t\t\tvec.assign(m + 1, 0);\r\n\t}\r\n\r\n\tvoid resize(int N, int M)\r\n\t{\r\n\t\tn = N;\r\n\t\tm = M;\r\n\t\tBIT.resize(n + 1);\r\n\r\n\t\tfor (vector<T> &vec : BIT)\r\n\t\t\tvec.assign(m + 1, 0);\r\n\t}\r\n\r\n\tT _query_(int x, int y)\r\n\t{\r\n\t\tT sum = 0;\r\n\r\n\t\tfor (int i = x; i > 0; i -= (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j > 0; j -= (j & -j))\r\n\t\t\t{\r\n\t\t\t\tsum += BIT[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tT query(int x2, int y2, int x1, int y1)\r\n\t{\r\n\t\treturn _query_(x2, y2) - _query_(x1 - 1, y2) - _query_(x2, y1 - 1) + _query_(x1 - 1, y1 - 1);\r\n\t}\r\n\r\n\tvoid update(int x, int y, T val)\r\n\t{\r\n\t\tfor (int i = x; i <= n; i += (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j <= m; j += (j & -j))\r\n\t\t\t{\r\n\t\t\t\tBIT[i][j] += val;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};"
    ],
    "description": "FenwickTree2D"
  },
  "FenwickTree3D": {
    "prefix": "FenwickTree3D",
    "body": [
      "template <class T>\r\nclass FenwickTree3D\r\n{\r\n\tint l, m, n;\r\n\tvector<vector<vector<T>>> BIT;\r\n\r\npublic:\r\n\tFenwickTree3D() {}\r\n\r\n\tFenwickTree3D(int L, int M, int N)\r\n\t{\r\n\t\tl = L;\r\n\t\tm = M;\r\n\t\tn = N;\r\n\r\n\t\tBIT.resize(l + 1);\r\n\r\n\t\tREP(i, 0, l)\r\n\t\t{\r\n\t\t\tBIT[i].resize(m + 1);\r\n\t\t\tREP(j, 0, m)\r\n\t\t\tBIT[i][j].assign(n + 1, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid resize(int L, int M, int N)\r\n\t{\r\n\t\tl = L;\r\n\t\tm = M;\r\n\t\tn = N;\r\n\r\n\t\tBIT.resize(l + 1);\r\n\r\n\t\tREP(i, 0, l)\r\n\t\t{\r\n\t\t\tBIT[i].resize(m + 1);\r\n\t\t\tREP(j, 0, m)\r\n\t\t\tBIT[i][j].assign(n + 1, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tT _query_(int x, int y, int z)\r\n\t{\r\n\t\tT sum = 0;\r\n\r\n\t\tfor (int i = x; i > 0; i -= (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j > 0; j -= (j & -j))\r\n\t\t\t{\r\n\t\t\t\tfor (int k = z; k > 0; k -= (k & -k))\r\n\t\t\t\t{\r\n\t\t\t\t\tsum += BIT[i][j][k];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tT query(int x2, int y2, int z2, int x1, int y1, int z1)\r\n\t{\r\n\t\treturn _query_(x2, y2, z2) - _query_(x1 - 1, y2, z2) - _query_(x2, y1 - 1, z2) - _query_(x2, y2, z1 - 1) - _query_(x1 - 1, y1 - 1, z1 - 1) + _query_(x1 - 1, y1 - 1, z2) + _query_(x1 - 1, y2, z1 - 1) + _query_(x2, y1 - 1, z1 - 1);\r\n\t}\r\n\r\n\tvoid update(int x, int y, int z, T val)\r\n\t{\r\n\t\tfor (int i = x; i <= l; i += (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j <= m; j += (j & -j))\r\n\t\t\t{\r\n\t\t\t\tfor (int k = z; k <= n; k += (k & -k))\r\n\t\t\t\t{\r\n\t\t\t\t\tBIT[i][j][k] += val;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};"
    ],
    "description": "FenwickTree3D"
  },
  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "template <class T>\r\nclass SegmentTree\r\n{\r\n\tint n;\r\n\tvector<T> segTree;\r\n\r\npublic:\r\n\tSegmentTree() {}\r\n\r\n\tSegmentTree(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t}\r\n\r\n\tvoid _build_(int si, int ss, int se, T arr[])\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si] = arr[ss];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\t_build_(2 * si, ss, mid, arr);\r\n\t\t\t_build_(2 * si + 1, mid + 1, se, arr);\r\n\t\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid build(T arr[])\r\n\t{\r\n\t\t_build_(1, 1, n, arr);\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qs, int qe)\r\n\t{\r\n\t\tif (qs > se || qe < ss)\r\n\t\t\treturn 0;\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t\treturn segTree[si];\r\n\t\tint mid = (ss + se) / 2;\r\n\t\treturn _query_(2 * si, ss, mid, qs, qe) + _query_(2 * si + 1, mid + 1, se, qs, qe);\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qi)\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t\treturn segTree[si];\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\tif (qi <= mid)\r\n\t\t\t\treturn _query_(2 * si, ss, mid, qi);\r\n\t\t\telse\r\n\t\t\t\treturn _query_(2 * si + 1, mid + 1, se, qi);\r\n\t\t}\r\n\t}\r\n\r\n\tT query(int l, int r)\r\n\t{\r\n\t\treturn _query_(1, 1, n, l, r);\r\n\t}\r\n\r\n\tT query(int qi)\r\n\t{\r\n\t\treturn _query_(1, 1, n, qi);\r\n\t}\r\n\r\n\tvoid _update_(int si, int ss, int se, int qi, T val)\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si] = val;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\tif (qi <= mid)\r\n\t\t\t\t_update_(2 * si, ss, mid, qi, val);\r\n\t\t\telse\r\n\t\t\t\t_update_(2 * si + 1, mid + 1, se, qi, val);\r\n\t\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid update(int qi, T val)\r\n\t{\r\n\t\t_update_(1, 1, n, qi, val);\r\n\t}\r\n};"
    ],
    "description": "SegmentTree"
  },
  "SegmentTreeLazyPropogation": {
    "prefix": "SegmentTreeLazyPropogation",
    "body": [
      "template <class T>\r\nclass SegmentTreeLazyPropogation\r\n{\r\n\tint n;\r\n\tvector<T> segTree;\r\n\tvector<T> lazy;\r\n\r\npublic:\r\n\tSegmentTreeLazyPropogation(){}\r\n\t\r\n\tSegmentTreeLazyPropogation(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t\tlazy.assign(4 * n, 0);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t\tlazy.assign(4 * n, 0);\r\n\t}\r\n\r\n\tvoid _build_(int si, int ss, int se, T arr[])\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si] = arr[ss];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\t_build_(2 * si, ss, mid, arr);\r\n\t\t\t_build_(2 * si + 1, mid + 1, se, arr);\r\n\t\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid build(T arr[])\r\n\t{\r\n\t\t_build_(1, 1, n, arr);\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qs, int qe)\r\n\t{\r\n\t\tif (lazy[si])\r\n\t\t{\r\n\t\t\tsegTree[si] += (se - ss + 1) * lazy[si];\r\n\r\n\t\t\tif (ss != se)\r\n\t\t\t\tlazy[2 * si] += lazy[si], lazy[2 * si + 1] += lazy[si];\r\n\r\n\t\t\tlazy[si] = 0;\r\n\t\t}\r\n\r\n\t\tif (qs > se || qe < ss)\r\n\t\t\treturn 0;\r\n\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t\treturn segTree[si];\r\n\r\n\t\tint mid = (ss + se) / 2;\r\n\t\treturn _query_(2 * si, ss, mid, qs, qe) + _query_(2 * si + 1, mid + 1, se, qs, qe);\r\n\t}\r\n\r\n\tT query(int l, int r=-1)\r\n\t{\r\n\t\tif(r==-1)r=l;\r\n\t\treturn _query_(1, 1, n, l, r);\r\n\t}\r\n\r\n\tvoid _update_(int si, int ss, int se, int qs, int qe, T val)\r\n\t{\r\n\t\tif (lazy[si])\r\n\t\t{\r\n\t\t\tsegTree[si] += (se - ss + 1) * lazy[si];\r\n\r\n\t\t\tif (ss != se)\r\n\t\t\t\tlazy[2 * si] += lazy[si], lazy[2 * si + 1] += lazy[si];\r\n\r\n\t\t\tlazy[si] = 0;\r\n\t\t}\r\n\r\n\t\tif (ss > qe || se < qs)\r\n\t\t\treturn;\r\n\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t{\r\n\t\t\tsegTree[si] += (se - ss + 1) * val;\r\n\r\n\t\t\tif (ss != se)\r\n\t\t\t\tlazy[2 * si] += val, lazy[2 * si + 1] += val;\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint mid = (ss + se) / 2;\r\n\r\n\t\t_update_(2 * si, ss, mid, qs, qe, val);\r\n\t\t_update_(2 * si + 1, mid + 1, se, qs, qe, val);\r\n\r\n\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t}\r\n\r\n\tvoid update(int l, int r, T val)\r\n\t{\r\n\t\t_update_(1, 1, n, l, r, val);\r\n\t}\r\n};"
    ],
    "description": "SegmentTreeLazyPropogation"
  },
  "mergeSortTree": {
    "prefix": "mergeSortTree",
    "body": [
      "const int arrSize = 30001;\r\nint arr[arrSize];\r\n\r\ntemplate <class T>\r\nclass mergeSortTree\r\n{\r\n\tint n;\r\n\tvector<T> segTree[4 * arrSize];\r\n\r\npublic:\r\n\tmergeSortTree() {}\r\n\r\n\tmergeSortTree(int N)\r\n\t{\r\n\t\tn = N;\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t}\r\n\r\n\tvoid _build_(int si, int ss, int se)\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si].push_back(arr[ss]);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\r\n\t\t\t_build_(2 * si, ss, mid);\r\n\t\t\t_build_(2 * si + 1, mid + 1, se);\r\n\r\n\t\t\tint i = 0, j = 0;\r\n\r\n\t\t\twhile (i < segTree[2 * si].size() && j < segTree[2 * si + 1].size())\r\n\t\t\t\tif (segTree[2 * si][i] < segTree[2 * si + 1][j])\r\n\t\t\t\t\tsegTree[si].push_back(segTree[2 * si][i++]);\r\n\t\t\t\telse\r\n\t\t\t\t\tsegTree[si].push_back(segTree[2 * si + 1][j++]);\r\n\r\n\t\t\twhile (i < segTree[2 * si].size())\r\n\t\t\t\tsegTree[si].push_back(segTree[2 * si][i++]);\r\n\r\n\t\t\twhile (j < segTree[2 * si + 1].size())\r\n\t\t\t\tsegTree[si].push_back(segTree[2 * si + 1][j++]);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid build()\r\n\t{\r\n\t\t_build_(1, 1, n);\r\n\t}\r\n\r\n\tint bs(int si, T val)\r\n\t{\r\n\t\tint start = 0, end = segTree[si].size() - 1;\r\n\r\n\t\twhile (start <= end)\r\n\t\t{\r\n\t\t\tint mid = (start + end) / 2;\r\n\r\n\t\t\tif (segTree[si][mid] <= val && (mid == end || segTree[si][mid + 1] > val))\r\n\t\t\t\treturn segTree[si].size() - 1 - mid;\r\n\t\t\telse if (segTree[si][mid] <= val)\r\n\t\t\t\tstart = mid + 1;\r\n\t\t\telse\r\n\t\t\t\tend = mid - 1;\r\n\t\t}\r\n\r\n\t\treturn segTree[si].size();\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qs, int qe, T val)\r\n\t{\r\n\t\tif (qs > se || qe < ss)\r\n\t\t\treturn 0;\r\n\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t\treturn bs(si, val);\r\n\r\n\t\tint mid = (ss + se) / 2;\r\n\r\n\t\treturn _query_(2 * si, ss, mid, qs, qe, val) + _query_(2 * si + 1, mid + 1, se, qs, qe, val);\r\n\t}\r\n\r\n\tT query(int l, int r, T val)\r\n\t{\r\n\t\treturn _query_(1, 1, n, l, r, val);\r\n\t}\r\n};"
    ],
    "description": "mergeSortTree"
  },
  "PersistentSegmentTree": {
    "prefix": "PersistentSegmentTree",
    "body": [
      "template <class T>\r\nclass PersistentSegmentTree\r\n{\r\n\tint n;\r\n\tvector<T> segTree;\r\n\tvector<int> left, right;\r\n\tvector<int> roots;\r\n\tint index;\r\n\r\npublic:\r\n\tPersistentSegmentTree() {}\r\n\r\n\tint build(int ss, int se)\r\n\t{\r\n\t\tint node = ++index;\r\n\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[node] = 0;\r\n\t\t\treturn node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\tleft[node] = build(ss, mid);\r\n\t\t\tright[node] = build(mid + 1, se);\r\n\t\t\tsegTree[node] = 0;\r\n\t\t\treturn node;\r\n\t\t}\r\n\t}\r\n\r\n\tPersistentSegmentTree(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(N * 21);\r\n\t\tleft.resize(N * 21);\r\n\t\tright.resize(N * 21);\r\n\t\tindex = 0;\r\n\t\troots.push_back(build(1, n));\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(N * 21);\r\n\t\tleft.resize(N * 21);\r\n\t\tright.resize(N * 21);\r\n\t\tindex = 0;\r\n\t\troots.push_back(build(1, n));\r\n\t}\r\n\r\n\tint _update_(int prevNode, int ss, int se, int qi, T val)\r\n\t{\r\n\t\tint node = ++index;\r\n\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[node] = segTree[prevNode] + val;\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tint mid = (ss + se) / 2;\r\n\r\n\t\tif (qi <= mid)\r\n\t\t{\r\n\t\t\tright[node] = right[prevNode];\r\n\t\t\tleft[node] = _update_(left[prevNode], ss, mid, qi, val);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tleft[node] = left[prevNode];\r\n\t\t\tright[node] = _update_(right[prevNode], mid + 1, se, qi, val);\r\n\t\t}\r\n\r\n\t\tsegTree[node] = segTree[left[node]] + segTree[right[node]];\r\n\t\treturn node;\r\n\t}\r\n\r\n\tvoid update(int index, T val)\r\n\t{\r\n\t\troots.push_back(_update_(roots.back(), 1, n, index, val));\r\n\t}\r\n\r\n\tT _query_(int nodeA, int nodeB, int ss, int se, int qs, int qe)\r\n\t{\r\n\t\tif (qs > se || qe < ss)\r\n\t\t\treturn 0;\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t\treturn segTree[nodeA] - segTree[nodeB];\r\n\t\tint mid = (ss + se) / 2;\r\n\t\treturn _query_(left[nodeA], left[nodeB], ss, mid, qs, qe) + _query_(right[nodeA], right[nodeB], mid + 1, se, qs, qe);\r\n\t}\r\n\r\n\tT _query_(int nodeA, int nodeB, int ss, int se, int k)\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t\treturn ss;\r\n\r\n\t\tint diff = segTree[left[nodeA]] - segTree[left[nodeB]];\r\n\t\tint mid = (ss + se) / 2;\r\n\r\n\t\tif (diff >= k)\r\n\t\t\treturn _query_(left[nodeA], left[nodeB], ss, mid, k);\r\n\t\telse\r\n\t\t\treturn _query_(right[nodeA], right[nodeB], mid + 1, se, k - diff);\r\n\t}\r\n\r\n\tT query(int ul, int ur, int qs, int qe = -1)\r\n\t{\r\n\t\tif (qe == -1)\r\n\t\t\treturn _query_(roots[ur], roots[ul - 1], 1, n, qs);\r\n\t\telse\r\n\t\t\treturn _query_(roots[ur], roots[ul - 1], 1, n, qs, qe);\r\n\t}\r\n};\r\n"
    ],
    "description": "PersistentSegmentTree"
  },
  "DSU": {
    "prefix": "DSU",
    "body": [
      "class DSU\r\n{\r\n\tint n;\r\n\tvector<int> par;\r\n\r\npublic:\r\n\tDSU(){}\r\n\r\n\tDSU(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tpar.assign(n + 1, -1);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tpar.assign(n + 1, -1);\r\n\t}\r\n\r\n\tint find(int a)\r\n\t{\r\n\t\tif (par[a] < 0)\r\n\t\t\treturn a;\r\n\t\telse\r\n\t\t\treturn par[a] = find(par[a]);\r\n\t}\r\n\r\n\tvoid merger(int a, int b)\r\n\t{\r\n\t\ta = find(a);\r\n\t\tb = find(b);\r\n\r\n\t\tif(a==b)return;\r\n\r\n\t\tif (par[a] > par[b])\r\n\t\t\tswap(a, b);\r\n\r\n\t\tpar[a] += par[b];\r\n\t\tpar[b] = a;\r\n\t}\r\n};"
    ],
    "description": "DSU"
  },
  "MO": {
    "prefix": "MO",
    "body": [
      "const int arrSize = 100001;\r\nint arr[arrSize];\r\n\r\ntemplate <class T>\r\nclass MO\r\n{\r\n\tstruct Query\r\n\t{\r\n\t\tint l, r, index;\r\n\t\tll order;\r\n\r\n\t\tQuery(int _l, int _r, int _index)\r\n\t\t{\r\n\t\t\tl = _l;\r\n\t\t\tr = _r;\r\n\t\t\tindex = _index;\r\n\t\t\torder = gilbertOrder(l, r, 21, 0);\r\n\t\t}\r\n\r\n\t\tinline int64_t gilbertOrder(int x, int y, int pow, int rotate)\r\n\t\t{\r\n\t\t\tif (pow == 0)\r\n\t\t\t{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tint hpow = 1 << (pow - 1);\r\n\t\t\tint seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ((y < hpow) ? 1 : 2);\r\n\t\t\tseg = (seg + rotate) & 3;\r\n\t\t\tconst int rotateDelta[4] = {3, 0, 0, 1};\r\n\t\t\tint nx = x & (x ^ hpow), ny = y & (y ^ hpow);\r\n\t\t\tint nrot = (rotate + rotateDelta[seg]) & 3;\r\n\t\t\tint64_t subSquareSize = int64_t(1) << (2 * pow - 2);\r\n\t\t\tint64_t ans = seg * subSquareSize;\r\n\t\t\tint64_t add = gilbertOrder(nx, ny, pow - 1, nrot);\r\n\t\t\tans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t};\r\n\r\n\tint n, q;\r\n\tT res;\r\n\tvector<T> fre, ans;\r\n\tvector<Query> Q;\r\n\r\npublic:\r\n\tMO() {}\r\n\r\n\t// N -> no of elements, Q -> no of queries, R -> range of elements\r\n\tMO(int N, int Q, int R)\r\n\t{\r\n\t\tn = N;\r\n\t\tq = Q;\r\n\t\tres = 0;\r\n\t\tfre.assign(R + 1, 0);\r\n\t\tans.resize(Q + 1);\r\n\t}\r\n\r\n\tvoid resize(int N, int Q, int R)\r\n\t{\r\n\t\tn = N;\r\n\t\tq = Q;\r\n\t\tres = 0;\r\n\t\tfre.assign(R + 1, 0);\r\n\t\tans.resize(Q + 1);\r\n\t}\r\n\r\n\tvoid addQuery(int l, int r, int index)\r\n\t{\r\n\t\tQ.push_back(Query(l, r, index));\r\n\t}\r\n\r\n\tvoid add(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\r\n\t\tif (++fre[ele] == 1)\r\n\t\t\tres++;\r\n\t}\r\n\r\n\tvoid remove(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\r\n\t\tif (--fre[ele] == 0)\r\n\t\t\tres--;\r\n\t}\r\n\r\n\tvoid processQuery()\r\n\t{\r\n\t\tsort(all(Q), [](const Query &lhs, const Query &rhs)\r\n\t\t\t { return lhs.order < rhs.order; });\r\n\r\n\t\tfor (int i = 0, L = 1, R = 0; i < q; i++)\r\n\t\t{\r\n\t\t\twhile (R < Q[i].r)\r\n\t\t\t\tadd(++R);\r\n\t\t\twhile (L > Q[i].l)\r\n\t\t\t\tadd(--L);\r\n\t\t\twhile (R > Q[i].r)\r\n\t\t\t\tremove(R--);\r\n\t\t\twhile (L < Q[i].l)\r\n\t\t\t\tremove(L++);\r\n\r\n\t\t\tans[Q[i].index] = res;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid showAns()\r\n\t{\r\n\t\tREP(i, 1, q)\r\n\t\t{\r\n\t\t\tcout << ans[i] << endl;\r\n\t\t}\r\n\t}\r\n};"
    ],
    "description": "MO"
  },
  "MOWithUpdate": {
    "prefix": "MOWithUpdate",
    "body": [
      "const int blk = 2100;\r\nconst int arrSize = 100001;\r\nconst int querSize = 100001;\r\nconst int freSize = 200001;\r\n\r\nstruct Query\r\n{\r\n\tint l, r, t, index;\r\n} q[querSize];\r\n\r\nstruct Update\r\n{\r\n\tint index, new_y, prev_y;\r\n} u[querSize];\r\n\r\nbool cmp(Query const &a, Query const &b)\r\n{\r\n\tif (a.t / blk != b.t / blk)\r\n\t\treturn a.t < b.t;\r\n\tif (a.l / blk != b.l / blk)\r\n\t\treturn a.l < b.l;\r\n\treturn a.r < b.r;\r\n}\r\n\r\nint arr[arrSize];  // array which contains main data\r\nint last[arrSize]; // last element present in the vector\r\nbool use[arrSize]; // used in update\r\nint fre[freSize];  // use to keep track of no of elements\r\n\r\n// extra variables\r\nint ff[arrSize];\r\nmap<int, int> mp;\r\n\r\ntemplate <class TYPE>\r\nclass MOWithUpdate\r\n{\r\n\tint n, m;\r\n\tint nq, nu;\r\n\tTYPE res;\r\n\tvector<TYPE> ans;\r\n\r\npublic:\r\n\tMOWithUpdate() {}\r\n\r\n\tMOWithUpdate(int N, int M)\r\n\t{\r\n\t\tn = N, m = M;\r\n\t\tnq = nu = res = 0;\r\n\t\tans.resize(M + 1);\r\n\t}\r\n\r\n\tvoid resize(int N, int M)\r\n\t{\r\n\t\tn = N, m = M;\r\n\t\tnq = nu = res = 0;\r\n\t\tans.resize(M + 1);\r\n\t}\r\n\r\n\tvoid addQuery(int a, int b)\r\n\t{\r\n\t\tnq++;\r\n\t\tq[nq].l = a;\r\n\t\tq[nq].r = b;\r\n\t\tq[nq].index = nq;\r\n\t\tq[nq].t = nu;\r\n\t}\r\n\r\n\tvoid addUpdate(int index, TYPE val)\r\n\t{\r\n\t\tnu++;\r\n\t\tu[nu].index = index;\r\n\t\tu[nu].new_y = val;\r\n\t\tu[nu].prev_y = last[index];\r\n\t\tlast[index] = val;\r\n\t}\r\n\r\n\tvoid add(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\t\tuse[index] = true;\r\n\r\n\t\t--ff[fre[ele]];\r\n\t\t++fre[ele];\r\n\t\t++ff[fre[ele]];\r\n\t}\r\n\r\n\tvoid remove(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\t\tuse[index] = false;\r\n\r\n\t\t--ff[fre[ele]];\r\n\t\t--fre[ele];\r\n\t\t++ff[fre[ele]];\r\n\t}\r\n\r\n\tvoid reflect_update(int index, int ele)\r\n\t{\r\n\t\tif (use[index] == false)\r\n\t\t{\r\n\t\t\tarr[index] = ele;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tremove(index);\r\n\t\tarr[index] = ele;\r\n\t\tadd(index);\r\n\t}\r\n\r\n\tvoid do_update(int index)\r\n\t{\r\n\t\treflect_update(u[index].index, u[index].new_y);\r\n\t}\r\n\r\n\tvoid undo(int index)\r\n\t{\r\n\t\treflect_update(u[index].index, u[index].prev_y);\r\n\t}\r\n\r\n\tint getAns()\r\n\t{\r\n\t\tREP(i, 1, 600)\r\n\t\tif (ff[i] == 0)\r\n\t\t\treturn i;\r\n\t}\r\n\r\n\tvoid processQueries()\r\n\t{\r\n\t\tsort(q + 1, q + nq + 1, cmp);\r\n\r\n\t\tfor (int i = 1, L = 2, R = 1, T = 0; i <= nq; i++)\r\n\t\t{\r\n\t\t\twhile (T < q[i].t)\r\n\t\t\t\tdo_update(++T);\r\n\t\t\twhile (T > q[i].t)\r\n\t\t\t\tundo(T--);\r\n\t\t\twhile (R < q[i].r)\r\n\t\t\t\tadd(++R);\r\n\t\t\twhile (L > q[i].l)\r\n\t\t\t\tadd(--L);\r\n\t\t\twhile (R > q[i].r)\r\n\t\t\t\tremove(R--);\r\n\t\t\twhile (L < q[i].l)\r\n\t\t\t\tremove(L++);\r\n\r\n\t\t\tans[q[i].index] = getAns();\r\n\t\t}\r\n\t}\r\n\r\n\tvoid showAns()\r\n\t{\r\n\t\tREP(i, 1, nq)\r\n\t\t\tcout << ans[i] << endl;\r\n\t}\r\n\r\n\tvoid preprocess()\r\n\t{\r\n\t\tint timer = 0;\r\n\r\n\t\tfor (auto &e : mp)\r\n\t\t\te.second = ++timer;\r\n\r\n\t\tREP(i, 1, n)\r\n\t\tarr[i] = mp[arr[i]];\r\n\r\n\t\tREP(i, 1, nu)\r\n\t\tu[i].new_y = mp[u[i].new_y],\r\n\t\tu[i].prev_y = mp[u[i].prev_y];\r\n\t}\r\n};\r\n\r\nvoid solve()\r\n{\r\n\tint n, m;\r\n\tcin >> n >> m;\r\n\r\n\tMOWithUpdate<int> mo(n, m);\r\n\r\n\tREP(i, 1, n)\r\n\t{\r\n\t\tcin >> arr[i];\r\n\t\tlast[i] = arr[i];\r\n\t\tmp[arr[i]];\r\n\t}\r\n\r\n\tREP(i, 1, m)\r\n\t{\r\n\t\tint type, a, b;\r\n\t\tcin >> type >> a >> b;\r\n\r\n\t\tif (type == 1)\r\n\t\t{\r\n\t\t\tmo.addQuery(a, b);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmp[b];\r\n\t\t\tmo.addUpdate(a, b);\r\n\t\t}\r\n\t}\r\n\r\n\tmo.preprocess();\r\n\tmo.processQueries();\r\n\tmo.showAns();\r\n}"
    ],
    "description": "MOWithUpdate"
  },
  "Tree": {
    "prefix": "Tree",
    "body": [
      "const int treeNode = 100001;\r\nvector<int> tree[treeNode];\r\n\r\n// for lca finding\r\nint level[treeNode], parent[treeNode][19];\r\n\r\n// euler tree tour technique\r\nint FT[2 * treeNode], intime[treeNode], outime[treeNode], timer;\r\n\r\nclass Tree\r\n{\r\n\tint n;\r\n\r\npublic:\r\n\tTree() {}\r\n\r\n\tTree(int N)\r\n\t{\r\n\t\tn = N;\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t}\r\n\r\n\tvoid addEdge(int a, int b)\r\n\t{\r\n\t\ttree[a].push_back(b), tree[b].push_back(a);\r\n\t}\r\n\r\n\tvoid euler(int node = 1, int par = -1, int l = 0)\r\n\t{\r\n\t\t// euler tree tour technique\r\n\t\tintime[node] = ++timer;\r\n\t\tFT[timer] = node;\r\n\r\n\t\t// lca\r\n\t\tparent[node][0] = par;\r\n\t\tlevel[node] = l;\r\n\r\n\t\tfor (int child : tree[node])\r\n\t\t{\r\n\t\t\tif (child == par)\r\n\t\t\t\tcontinue;\r\n\t\t\teuler(child, node, l + 1);\r\n\t\t}\r\n\r\n\t\t// euler tree tour technique\r\n\t\toutime[node] = ++timer;\r\n\t\tFT[timer] = node;\r\n\t}\r\n\r\n\tvoid init()\r\n\t{\r\n\t\teuler();\r\n\r\n\t\t// lca portion\r\n\t\tfor (int j = 1; j < 19; j++)\r\n\t\t\tfor (int i = 1; i <= n; i++)\r\n\t\t\t\tif (parent[i][j - 1] == -1)\r\n\t\t\t\t\tparent[i][j] = -1;\r\n\t\t\t\telse\r\n\t\t\t\t\tparent[i][j] = parent[parent[i][j - 1]][j - 1];\r\n\t}\r\n\r\n\tint LCA(int a, int b)\r\n\t{\r\n\t\tif (level[a] < level[b])\r\n\t\t\tswap(a, b);\r\n\r\n\t\tint d = level[a] - level[b];\r\n\r\n\t\twhile (d)\r\n\t\t{\r\n\t\t\tint i = log2(d);\r\n\t\t\ta = parent[a][i];\r\n\t\t\td -= 1 << i;\r\n\t\t}\r\n\r\n\t\tif (a == b)\r\n\t\t\treturn a;\r\n\r\n\t\tfor (int i = 18; i >= 0; i--)\r\n\t\t\tif (parent[a][i] != -1 && parent[a][i] != parent[b][i])\r\n\t\t\t\ta = parent[a][i], b = parent[b][i];\r\n\r\n\t\treturn parent[a][0];\r\n\t}\r\n\r\n\tvoid pathQuery(int a, int b)\r\n\t{\r\n\t\tif (intime[a] > intime[b])\r\n\t\t\tswap(a, b);\r\n\r\n\t\tint lca = LCA(a, b);\r\n\r\n\t\tif (a == lca)\r\n\t\t{\r\n\t\t\tint l = intime[a];\r\n\t\t\tint r = intime[b];\r\n\r\n\t\t\t// no need to include LCA\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint l = outime[a];\r\n\t\t\tint r = intime[b];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid subTreeQuery(int a)\r\n\t{\r\n\t\tint l = intime[a] - 1;\r\n\t\tint r = outime[a] + 1;\r\n\t}\r\n};"
    ],
    "description": "Tree"
  },
  "Dijkstra": {
    "prefix": "Dijkstra",
    "body": [
      "int n, m;\r\nconst int maxNode = 200001;\r\nvector<pair<int, ll>> grp[maxNode];\r\nll dist[maxNode];\r\n\r\nvoid dijkstra(int src = 1)\r\n{\r\n\tREP(i, 1, n)\r\n\tdist[i] = 1e18;\r\n\r\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\r\n\tdist[src] = 0;\r\n\tq.push({0, src});\r\n\r\n\twhile (!q.empty())\r\n\t{\r\n\t\tint node = q.top().second;\r\n\t\tll d = q.top().first;\r\n\t\tq.pop();\r\n\r\n\t\tif (d != dist[node])\r\n\t\t\tcontinue;\r\n\r\n\t\tfor (pair<int, ll> child : grp[node])\r\n\t\t{\r\n\t\t\tif (dist[child.first] > dist[node] + child.second)\r\n\t\t\t{\r\n\t\t\t\tdist[child.first] = dist[node] + child.second;\r\n\t\t\t\tq.push({dist[child.first], child.first});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
    ],
    "description": "Dijkstra"
  },
  "sqrtDecomposition": {
    "prefix": "sqrtDecomposition",
    "body": [
      "const int blk = 900;\r\nconst int f_size = 120;\r\nll arr[maxN], f[f_size];\t// f_size = maxN / blk;\r\n\r\nclass sqrtDecomposition\r\n{\r\npublic:\r\n\tvoid init()\r\n\t{\r\n\t\tmemset(f, INT_MAX, sizeof(f));   \r\n\t\t\r\n\t\tREP(i, 1, n)\r\n\t\tf[i / blk] = min(arr[i], f[i / blk]);\r\n\t}\r\n\r\n\tll query(int l, int r)\r\n\t{\r\n\t\tint lblk = l / blk;\r\n\t\tint rblk = r / blk;\r\n\r\n\t\tll res = INT_MAX;\r\n\r\n\t\tif (lblk == rblk)\r\n\t\t{\r\n\t\t\tREP(i, l, r)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, arr[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tREP(i, l, blk * (lblk + 1) - 1)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, arr[i]);\r\n\t\t\t}\r\n\r\n\t\t\tREP(i, lblk + 1, rblk - 1)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, f[i]);\r\n\t\t\t}\r\n\r\n\t\t\tREP(i, rblk * blk, r)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, arr[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n};"
    ],
    "description": "sqrtDecomposition"
  },
  "TrieString": {
    "prefix": "TrieString",
    "body": [
      "const int sz = 26;\r\n\r\nclass TrieString\r\n{\r\n    struct Node\r\n    {\r\n        int endOfWord;\r\n        Node *arr[sz];\r\n        int cnt;\r\n\r\n        Node()\r\n        {\r\n            endOfWord = 0;\r\n            REP(i, 0, sz - 1)\r\n            arr[i] = NULL;\r\n            cnt = 0;\r\n        }\r\n    };\r\n\r\n    Node *root;\r\n\r\npublic:\r\n    TrieString()\r\n    {\r\n        root = new Node();\r\n    }\r\n\r\n    void insert(string &s)\r\n    {\r\n        Node *temp = root;\r\n\r\n        for (char c : s)\r\n        {\r\n            int index = c - 'a';\r\n\r\n            if (temp->arr[index] == NULL)\r\n                temp->arr[index] = new Node();\r\n\r\n            temp = temp->arr[index];\r\n            temp->cnt++;\r\n        }\r\n\r\n        temp->endOfWord++;\r\n    }\r\n\r\n    bool search(string &s)\r\n    {\r\n        Node *temp = root;\r\n        if (temp == NULL)\r\n            return false;\r\n\r\n        for (char c : s)\r\n        {\r\n            int index = c - 'a';\r\n\r\n            if (temp->arr[index] == NULL || temp->arr[index]->cnt == 0)\r\n                return false;\r\n\r\n            temp = temp->arr[index];\r\n        }\r\n\r\n        return temp->endOfWord;\r\n    }\r\n\r\n    void del(string &s)\r\n    {\r\n        if (search(s) == false)\r\n            return;\r\n\r\n        Node *temp = root;\r\n\r\n        for (char c : s)\r\n        {\r\n            int index = c - 'a';\r\n            temp = temp->arr[index];\r\n            temp->cnt--;\r\n        }\r\n\r\n        temp->endOfWord--;\r\n    }\r\n};"
    ],
    "description": "TrieString"
  },
  "TrieBit": {
    "prefix": "TrieBit",
    "body": [
      "const int sz = 2;\r\n\r\nclass TrieBit\r\n{\r\n\tstruct Node\r\n\t{\r\n\t\tNode *arr[sz];\r\n\t\tint cnt;\r\n\r\n\t\tNode()\r\n\t\t{\r\n\t\t\tREP(i, 0, sz - 1)\r\n\t\t\tarr[i] = NULL;\r\n\t\t\tcnt = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tNode *root;\r\n\r\npublic:\r\n\tTrieBit()\r\n\t{\r\n\t\troot = new Node();\r\n\t}\r\n\r\n\tvoid insert(ll s)\r\n\t{\r\n\t\tNode *temp = root;\r\n\r\n\t\tRREP(i, 63, 0)\r\n\t\t{\r\n\t\t\tif (s & (1LL << i))\r\n\t\t\t{\r\n\t\t\t\tif (temp->arr[1] == NULL)\r\n\t\t\t\t\ttemp->arr[1] = new Node();\r\n\t\t\t\ttemp = temp->arr[1];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (temp->arr[0] == NULL)\r\n\t\t\t\t\ttemp->arr[0] = new Node();\r\n\t\t\t\ttemp = temp->arr[0];\r\n\t\t\t}\r\n\r\n\t\t\ttemp->cnt++;\r\n\t\t}\r\n\t}\r\n\r\n\tbool search(ll s)\r\n\t{\r\n\t\tNode *temp = root;\r\n\t\tif(temp==NULL)return false;\r\n\r\n\t\tRREP(i, 63, 0)\r\n\t\t{\r\n\t\t\tif (s & (1LL << i))\r\n\t\t\t{\r\n\t\t\t\tif (temp->arr[1] == NULL || temp->arr[1]->cnt == 0)\r\n\t\t\t\t\treturn false;\r\n\t\t\t\ttemp = temp->arr[1];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (temp->arr[0] == NULL || temp->arr[0]->cnt == 0)\r\n\t\t\t\t\treturn false;\r\n\t\t\t\ttemp = temp->arr[0];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tvoid del(ll s)\r\n\t{\r\n\t\tif (search(s) == false)\r\n\t\t\treturn;\r\n\r\n\t\tNode *temp = root;\r\n\r\n\t\tRREP(i, 63, 0)\r\n\t\t{\r\n\t\t\tif (s & (1LL << i))\r\n\t\t\t{\r\n\t\t\t\ttemp = temp->arr[1];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttemp = temp->arr[0];\r\n\t\t\t}\r\n\r\n\t\t\ttemp->cnt--;\r\n\t\t}\r\n\t}\r\n\r\n\tll calc(ll s)\r\n\t{\r\n\t\tNode *temp = root;\r\n\t\tll ans = 0;\r\n\r\n\t\tRREP(i, 63, 0)\r\n\t\t{\r\n\t\t\tif (s & (1LL << i))\r\n\t\t\t{\r\n\t\t\t\tif (temp->arr[0] && temp->arr[0]->cnt)\r\n\t\t\t\t{\r\n\t\t\t\t\tans |= (1LL << i);\r\n\t\t\t\t\ttemp = temp->arr[0];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttemp = temp->arr[1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (temp->arr[1] && temp->arr[1]->cnt)\r\n\t\t\t\t{\r\n\t\t\t\t\tans |= (1LL << i);\r\n\t\t\t\t\ttemp = temp->arr[1];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttemp = temp->arr[0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn ans;\r\n\t}\r\n};\r\n"
    ],
    "description": "TrieBit"
  },
  "MaximumConvexHull": {
    "prefix": "MaximumConvexHull",
    "body": [
      "struct Line\r\n{\r\n    mutable ll m, b, p;\r\n    bool operator<(const Line &o) const { return m < o.m; }\r\n    bool operator<(ll x) const { return p < x; }\r\n};\r\n\r\n// for maximum value\r\nstruct LineContainer : multiset<Line, less<>>\r\n{\r\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\r\n    const ll inf = LLONG_MAX;\r\n    \r\n    ll div(ll a, ll b)\r\n    { // floored division\r\n        return a / b - ((a ^ b) < 0 && a % b);\r\n    }\r\n\r\n    bool isect(iterator x, iterator y)\r\n    {\r\n        if (y == end())\r\n        {\r\n            x->p = inf;\r\n            return false;\r\n        }\r\n        if (x->m == y->m)\r\n            x->p = x->b > y->b ? inf : -inf;\r\n        else\r\n            x->p = div(y->b - x->b, x->m - y->m);\r\n        return x->p >= y->p;\r\n    }\r\n    \r\n    void add(ll m, ll b)\r\n    {\r\n        auto z = insert({m, b, 0}), y = z++, x = y;\r\n        while (isect(y, z))\r\n            z = erase(z);\r\n        if (x != begin() && isect(--x, y))\r\n            isect(x, y = erase(y));\r\n        while ((y = x) != begin() && (--x)->p >= y->p)\r\n            isect(x, erase(y));\r\n    }\r\n    \r\n    ll query(ll x)\r\n    {\r\n        assert(!empty());\r\n        auto l = *lower_bound(x);\r\n        return l.m * x + l.b;\r\n    }\r\n} cht;\r\n"
    ],
    "description": "MaximumConvexHull"
  },
  "MinimumConvexHull": {
    "prefix": "MinimumConvexHull",
    "body": [
      "struct Line\r\n{\r\n    mutable ll m, b, p;\r\n    bool operator<(const Line &o) const { return m < o.m; }\r\n    bool operator<(ll x) const { return p < x; }\r\n};\r\n\r\nstruct LineContainer : multiset<Line, less<>>\r\n{\r\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\r\n    const ll inf = LLONG_MAX;\r\n\r\n    ll div(ll a, ll b)\r\n    { // floored division\r\n        return a / b - ((a ^ b) < 0 && a % b);\r\n    }\r\n\r\n    bool isect(iterator x, iterator y)\r\n    {\r\n        if (y == end())\r\n        {\r\n            x->p = inf;\r\n            return false;\r\n        }\r\n        if (x->m == y->m)\r\n            x->p = x->b > y->b ? inf : -inf;\r\n        else\r\n            x->p = div(y->b - x->b, x->m - y->m);\r\n        return x->p >= y->p;\r\n    }\r\n\r\n    void add(ll m, ll b)\r\n    {\r\n        m *= -1, b *= -1;\r\n        auto z = insert({m, b, 0}), y = z++, x = y;\r\n        while (isect(y, z))\r\n            z = erase(z);\r\n        if (x != begin() && isect(--x, y))\r\n            isect(x, y = erase(y));\r\n        while ((y = x) != begin() && (--x)->p >= y->p)\r\n            isect(x, erase(y));\r\n    }\r\n\r\n    ll query(ll x)\r\n    {\r\n        assert(!empty());\r\n        auto l = *lower_bound(x);\r\n        return -1 * (l.m * x + l.b);\r\n    }\r\n} cht;"
    ],
    "description": "MinimumConvexHull"
  },
  "digitDP2Flags": {
    "prefix": "digitDP2Flags",
    "body": [
      "string str1, str2;\r\nll dp[10][2][2][82];\r\nint N;\r\n\r\n// flag1 -> for lower bound\r\n// flag2 -> for upper bound\r\n\r\nll digitDP(int pos, int flag1 = 1, int flag2 = 1, ll res = 0)\r\n{\r\n    if (pos < 0)\r\n        return res;\r\n    else if (dp[pos][flag1][flag2][res] != -1)\r\n        return dp[pos][flag1][flag2][res];\r\n    else\r\n    {\r\n        ll ans = 0;\r\n        int lb = flag1 ? (str1[pos] - '0') : 0;\r\n        int ub = flag2 ? (str2[pos] - '0') : 9;\r\n\r\n        REP(i, lb, ub)\r\n        {\r\n            ans += digitDP(pos - 1, (i == lb & flag1), (i == ub & flag2), res + i);\r\n        }\r\n\r\n        return dp[pos][flag1][flag2][res] = ans;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    cin >> str1 >> str2;\r\n\r\n    if (str1[0] == '-')\r\n    {\r\n        return;\r\n    }\r\n\r\n    // str1 -> lower bound\r\n    // str2 -> upper bound\r\n\r\n    N = str2.size();\r\n\r\n    reverse(all(str1));\r\n    reverse(all(str2));\r\n\r\n    while (str1.size() < str2.size())\r\n    {\r\n        str1.push_back('0');\r\n    }\r\n\r\n    memset(dp, -1, sizeof(dp));\r\n    cout << digitDP(N - 1) << endl;\r\n}"
    ],
    "description": "digitDP2Flags"
  },
  "digitDP1Flags": {
    "prefix": "digitDP1Flags",
    "body": [
      "string str;\r\nll dp[10][2][82];\r\nint N;\r\n\r\nll digitDP(int pos = 0, int flag = 1, ll res = 0)\r\n{\r\n    if (pos == N)\r\n        return res;\r\n    else if (dp[pos][flag][res] != -1)\r\n        return dp[pos][flag][res];\r\n    else\r\n    {\r\n        ll ans = 0;\r\n        int ub = flag ? (str[pos] - '0') : 9;\r\n\r\n        REP(i, 0, ub)\r\n        {\r\n            ans += digitDP(pos + 1, (i == ub & flag), res + i);\r\n        }\r\n\r\n        return dp[pos][flag][res] = ans;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll ans = 0;\r\n    cin >> str;\r\n    N = str.size();\r\n    ans -= digitDP();\r\n\r\n    cin >> str;\r\n    N = str.size();\r\n    ans += digitDP();\r\n}"
    ],
    "description": "digitDP1Flags"
  },
  "digitDPOptimized": {
    "prefix": "digitDPOptimized",
    "body": [
      "string str1;\r\nstring str2;\r\nll dp[19][18];\r\nint N;\r\n\r\nll digitDP(int pos, int flag1 = 1, int flag2 = 1, int val=0)\r\n{\r\n    if (pos == -1)\r\n        return val==0;\r\n\r\n    ll &res = dp[pos][val];\r\n\r\n    if (flag1 == 0 && flag2 == 0 && res != -1)\r\n        return res;\r\n\r\n    ll ans = 0;\r\n    \r\n    int lb = flag1 ? (str1[pos] - '0') : 0;\r\n    int ub = flag2 ? (str2[pos] - '0') : 9;\r\n\r\n    REP(i, lb, ub)\r\n    {\r\n        ans += digitDP(pos - 1, (i==lb && flag1), (i == ub & flag2), val+i);\r\n    }\r\n\r\n    return flag1==0 && flag2==0 ? res = ans: ans;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    cin >> str1 >> str2;\r\n\r\n    reverse(all(str1));\r\n    reverse(all(str2));\r\n\r\n    while (str1.size() < str2.size())\r\n    {\r\n        str1.push_back('0');\r\n    }\r\n\r\n    N = str1.size();\r\n    ll ans = digitDP(N - 1);\r\n    cout << ans << endl;\r\n}\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\r\n    // freopen(\"input.txt\",\"r\",stdin);\r\n    // freopen(\"output.txt\",\"w\",stdout);\r\n\r\n    memset(dp, -1, sizeof(dp));\r\n\r\n    int t = 1;\r\n    cin >> t;\r\n\r\n    REP(tc, 1, t)\r\n    {\r\n        // cout<<\"Case \"<<tc<<\":\"<<endl;\r\n        solve();\r\n    }\r\n\r\n    return 0;\r\n}"
    ],
    "description": "digitDPOptimized"
  },
  "digitDPUsingHighAndLow": {
    "prefix": "digitDPUsingHighAndLow",
    "body": [
      "string str;\r\nint N;\r\nll dp[19][20][20][20];\r\n\r\nll digitDp(int pos, int left_lo, int left_hi, int zeros=0)\r\n{\r\n    if(pos>(N-1-pos+zeros))\r\n    {\r\n        return left_lo<=left_hi;\r\n    }\r\n\r\n    if(dp[pos][left_lo][left_hi][zeros]!=-1)\r\n        return dp[pos][left_lo][left_hi][zeros];\r\n\r\n    ll ans = 0;\r\n\r\n    REP(i,0,9)\r\n    {\r\n        int nlo = left_lo;\r\n        int nhi = left_hi;\r\n\r\n        if(i < (str[pos]-'0') && pos < nlo)nlo=pos;\r\n        if(i < (str[N-1-pos+zeros]-'0') && N-1-pos+zeros<nlo)nlo=N-1-pos+zeros;\r\n        if(i > (str[pos]-'0') && pos < nhi)nhi=pos;\r\n        if(i > (str[N-1-pos+zeros]-'0') && N-1-pos+zeros < nhi)nhi=N-1-pos+zeros;\r\n\r\n        ans += digitDp(pos+1,nlo,nhi,zeros + (zeros==pos && i==0));\r\n    }\r\n\r\n    return dp[pos][left_lo][left_hi][zeros] = ans;\r\n}\r\n\r\nint check(string &s)\r\n{\r\n    int i = 0, j = s.size()-1;\r\n\r\n    while (i < j)\r\n    {\r\n        if(s[i]!=s[j])\r\n            return 0;\r\n        i++,j--;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll ans = 0;\r\n    cin>>str;\r\n    N = str.size();\r\n    memset(dp,-1,sizeof(dp));\r\n    ans-=digitDp(0,N+1,N+1,0);\r\n    ans+=check(str);\r\n    \r\n    cin>>str;\r\n    N = str.size();\r\n    memset(dp,-1,sizeof(dp));\r\n    ans+=digitDp(0,N+1,N+1,0);\r\n    \r\n    cout<<ans<<endl;\r\n}"
    ],
    "description": "digitDPUsingHighAndLow"
  },
  "binExp": {
    "prefix": "binExp",
    "body": [
      "ll binExp(ll a, ll p, ll m=mod)\r\n{\r\n\tll res = 1;\r\n\ta %= m;\r\n \r\n\twhile (p)\r\n\t{\r\n\t\tif(p & 1)\r\n\t\t\tres = (res * a) % m;\r\n\t\ta = (a * a) % m;\r\n\t\tp>>=1;\r\n\t}\r\n\t\r\n\treturn res;\r\n}\r\n"
    ],
    "description": "binExp"
  },
  "mulmod": {
    "prefix": "mulmod",
    "body": [
      "ll mulmod(ll a, ll b, ll c)\r\n{\r\n\tll x = 0, y = a % c;\r\n\t\r\n\twhile (b > 0)\r\n\t{\r\n\t\tif (b % 2 == 1)\r\n\t\t{\r\n\t\t\tx = (x + y) % c;\r\n\t\t}\r\n\t\ty = (y * 2LL) % c;\r\n\t\tb /= 2;\r\n\t}\r\n\r\n\treturn x % c;\r\n}"
    ],
    "description": "mulmod"
  },
  "eulerTotient": {
    "prefix": "eulerTotient",
    "body": [
      "const int totNum=1e6;\r\nll phi[totNum+10];\r\n \r\nvoid init()\r\n{\r\n\tphi[1]=1;\r\n\r\n\tREP(i,2,totNum)\r\n\t{\r\n\t\tif (phi[i] == 0)\r\n\t\t{\r\n\t\t\tfor (ll j = i; j <= totNum; j += i)\r\n\t\t\t{\r\n\t\t\t\tif(phi[j]==0)phi[j]=j;\r\n\t\t\t\tphi[j] /= i;\r\n\t\t\t\tphi[j] *= i - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
    ],
    "description": "eulerTotient"
  },
  "divisors": {
    "prefix": "divisors",
    "body": [
      "void divisor(long long n)\r\n{\r\n\tfor (int d : {2, 3, 5})\r\n\t{\r\n\t\twhile (n % d == 0)\r\n\t\t{\r\n\t\t\tcout << d << \" \";\r\n\t\t\tn /= d;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic array<int, 8> increments = {4, 2, 4, 2, 4, 6, 2, 6};\r\n\r\n\tfor (long long d = 7, i = 0; d * d <= n; d += increments[i], i = (i + 1) % 8)\r\n\t{\r\n\t\twhile (n % d == 0)\r\n\t\t{\r\n\t\t\tcout << d << \" \";\r\n\t\t\tn /= d;\r\n\t\t}\r\n\t}\r\n\r\n\tif (n > 1)\r\n\t\tcout << n << \" \";\r\n}"
    ],
    "description": "divisor"
  },
  "primarity test brute force": {
    "prefix": "primarity test brute force",
    "body": [
      "bool primeCheck(ll n)\r\n{\r\n\tif (n <= 1)\r\n\t\treturn false;\r\n\r\n\tfor (ll d : {2, 3, 5})\r\n\t{\r\n\t\tif (n == d)\r\n\t\t\treturn true;\r\n\r\n\t\tif (n % d == 0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\tstatic array<ll, 8> increments = {4, 2, 4, 2, 4, 6, 2, 6};\r\n\r\n\tfor (long long d = 7, i = 0; d * d <= n; d += increments[i], i = (i + 1) % 8)\r\n\t{\r\n\t\tif(n % d == 0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n"
    ],
    "description": "primarity test brute force"
  },
  "Primality Test Sieve": {
    "prefix": "Primality Test Sieve",
    "body": [
      "const int totNum=1e8;\r\nbool primer[totNum/2+10];\r\n \r\nvoid init()\r\n{\r\n\tprimer[0] = primer[1] = true;\r\n \r\n\tfor (int i = 3; i * i <= totNum; i+=2)\r\n\t{\r\n\t\tif (primer[(i+1)/2] == false)\r\n\t\t{\r\n\t\t\tfor (int j = i * i; j <= totNum; j+=2*i)\r\n\t\t\t{\r\n\t\t\t\tprimer[(j+1)/2] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n \r\nbool isPrime(int n)\r\n{\r\n\tif(n==2)return true;\r\n\tif(n<2||n%2==0)return false;\r\n\treturn primer[(n+1)/2]==false;\r\n}\r\n"
    ],
    "description": "Primality Test Sieve"
  },
  "Factorization - Sieve": {
    "prefix": "Factorization - Sieve",
    "body": [
      "const int totNum = 5000000;\r\nint sieve[totNum + 10];\r\n\r\nvoid init()\r\n{\r\n\tfor (ll i = 2; i <= totNum; i++)\r\n\t\tif (sieve[i] == 0)\r\n\t\t{\r\n\t\t\tsieve[i] = i;\r\n\r\n\t\t\tfor (ll j = i * i; j <= totNum; j += i)\r\n\t\t\t\tif (sieve[j] == 0)\r\n\t\t\t\t\tsieve[j] = i;\r\n\t\t}\r\n\r\n\tsieve[1] = 1;\r\n}\r\n\r\nvoid getDivisor(int n)\r\n{\r\n\twhile (n > 1)\r\n\t{\r\n\t\tcout << sieve[n] << \" \";\r\n\t\tn /= sieve[n];\r\n\t}\r\n\tcout << endl;\r\n}"
    ],
    "description": "Factorization - Sieve"
  },
  "Primality Test Using Segmented-Sieve": {
    "prefix": "Primality Test Using Segmented-Sieve",
    "body": [
      "ll L = 1000000000;",
      "const int diff = 100010;",
      "ll R = 1001000000;",
      "const int totNum = 31630; // sqrt(R)",
      "bool primer[totNum / 2 + 10];",
      "bool primerSieve[diff];",
      "vector<ll> primes;",
      "",
      "void segmentedSieve()",
      "{",
      "    for (ll prime : primes)",
      "    {",
      "        for (ll i = max(prime * prime, ((L + prime - 1) / prime) * prime); i <= R; i += prime)",
      "            primerSieve[i - L] = true;",
      "    }",
      "",
      "    if (L == 1)",
      "        primerSieve[0] = true;",
      "}",
      "",
      "bool isPrime(int n)",
      "{",
      "    if (n == 2)",
      "        return true;",
      "    if (n < 2 || n % 2 == 0)",
      "        return false;",
      "    return primer[(n + 1) / 2] == false;",
      "}",
      "",
      "void init()",
      "{",
      "    primer[0] = primer[1] = true;",
      "",
      "    for (int i = 3; i * i <= totNum; i += 2)",
      "        if (primer[(i + 1) / 2] == false)",
      "            for (int j = i * i; j <= totNum; j += 2 * i)",
      "                primer[(j + 1) / 2] = true;",
      "",
      "    REP(i, 2, totNum)",
      "    if (isPrime(i))",
      "        primes.push_back(i);",
      "}",
      "",
      "bool isPrimeSieve(ll x)",
      "{",
      "    return primerSieve[x - L] == false;",
      "}"
    ],
    "description": "Primality Test Using Segmented-Sieve"
  },
  "Primality Test Using Linear Sieve": {
    "prefix": "Primality Test Using Linear Sieve",
    "body": [
      "const int totNum=1e6;",
      "int lp[totNum+10]; // for prime no i, lp[i]==i",
      "vector<int> primes; // contains all prime less <= totNums",
      " ",
      "void init()",
      "{",
      "    for (int i=2; i<maxN; ++i) ",
      "    {",
      "        if (lp[i] == 0) ",
      "        {",
      "            lp[i] = i;",
      "            primes.push_back (i);",
      "        }",
      "    ",
      "        for (int j=0; j< primes.size() && primes[j]<=lp[i] && 1LL*i*primes[j]<=totNum; ++j)",
      "            lp[i * primes[j]] = primes[j];",
      "    }",
      "}",
      "",
      "bool isPrime(int x)",
      "{",
      "    return lp[x]==x;",
      "}"
    ],
    "description": "Primality Test Using Linear Sieve"
  },
  "Miller-Rabin primality test": {
    "prefix": "Miller-Rabin primality test",
    "body": [
      "ll mulmod(ll a, ll b, ll c)",
      "{",
      "    ll x = 0, y = a % c;",
      "    while (b > 0)",
      "    {",
      "        if (b % 2 == 1)",
      "            x = (x + y) % c;",
      "        y = (y * 2LL) % c;",
      "        b /= 2;",
      "    }",
      "    return x % c;",
      "}",
      "",
      "ll binExp(ll a, ll power, ll m = mod)",
      "{",
      "    ll res = 1;",
      "",
      "    while (power)",
      "    {",
      "        if (power & 1)",
      "            res = mulmod(res, a, m);",
      "        a = mulmod(a, a, m);",
      "        power >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "// for testing a 32 bit integer it is only necessary to check the first 4 prime bases: 2, 3, 5 and 7. And for testing 64 bit integer it is enough to check the first 12 prime bases: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.",
      "",
      "bool isComposite(ll a, ll d, ll s, ll n)",
      "{",
      "    ll res = binExp(a, d, n);",
      "",
      "    if (res == 1 || res == n - 1)",
      "        return false;",
      "",
      "    for (ll i = 1; i < s; i++)",
      "    {",
      "        res = mulmod(res, res, n);",
      "        if (res == n - 1)",
      "            return false;",
      "    }",
      "",
      "    return true;",
      "}",
      "",
      "bool millerRabin(ll n)",
      "{",
      "    if (n <= 4)",
      "    {",
      "        return (n == 2 || n == 3);",
      "    }",
      "",
      "    if (n % 2 == 0)",
      "        return false;",
      "",
      "    ll d = n - 1, s = 0;",
      "",
      "    while (d % 2 == 0)",
      "    {",
      "        d /= 2;",
      "        s++;",
      "    }",
      "",
      "    for (ll a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37})",
      "    {",
      "        if (n == a)",
      "            return true;",
      "",
      "        if (isComposite(a, d, s, n))",
      "            return false;",
      "    }",
      "",
      "    return true;",
      "}"
    ],
    "description": "Miller-Rabin primality test"
  },
  "gcd and lcm": {
    "prefix": "gcd and lcm",
    "body": [
      "ll gcd(ll a, ll b)",
      "{",
      "    return (b == 0) ? a : gcd(b, a % b);",
      "}",
      "",
      "ll lcm(ll a, ll b)",
      "{",
      "    return (a * b) / gcd(a, b);",
      "}"
    ],
    "description": "gcd and lcm"
  },
  "matrix exponentiation": {
    "prefix": "matrix exponentiation",
    "body": [
      "ll transition_matrix[2][2];",
      "ll identity_matrix[2][2];",
      "",
      "void multiply(ll matrix_a[][2], ll matrix_b[][2])",
      "{",
      "    ll result[2][2];",
      "",
      "    REP(i, 0, 1)",
      "    REP(j, 0, 1)",
      "    {",
      "        result[i][j] = 0;",
      "",
      "        REP(k, 0, 1)",
      "        {",
      "            result[i][j] += matrix_a[i][k] * matrix_b[k][j];",
      "            result[i][j] %= mod;",
      "        }",
      "    }",
      "",
      "    REP(i, 0, 1)",
      "    REP(j, 0, 1)",
      "    matrix_b[i][j] = result[i][j];",
      "}",
      "",
      "void matrixPower(ll power)",
      "{",
      "    transition_matrix[0][0] = 0;",
      "    transition_matrix[0][1] = transition_matrix[1][0] = transition_matrix[1][1] = 1;",
      "",
      "    identity_matrix[0][0] = identity_matrix[1][1] = 1;",
      "    identity_matrix[0][1] = identity_matrix[1][0] = 0;",
      "",
      "    while (power)",
      "    {",
      "        if (power % 2)",
      "            multiply(transition_matrix, identity_matrix);",
      "",
      "        power /= 2;",
      "        multiply(transition_matrix, transition_matrix);",
      "    }",
      "}"
    ],
    "description": "matrix exponentiation"
  },
  "fibonacci number": {
    "prefix": "fibonacci number",
    "body": [
      "void fib(ll n, ll&x, ll&y){",
      "    if(n==0){",
      "        x = 0;",
      "        y = 1;",
      "        return ;",
      "    }",
      "     ",
      "    if(n&1){",
      "        fib(n-1, y, x);",
      "        y=(y+x)%mod;",
      "    }else{",
      "        ll a, b;",
      "        fib(n>>1, a, b);",
      "        y = (a*a+b*b)%mod;",
      "        x = (a*b + a*(b-a+mod))%mod;",
      "    }",
      "}"
    ],
    "description": "fibonacci number"
  },
  "Heavy Light Decomposition": {
    "prefix": "Heavy Light Decomposition",
    "body": [
      "template <class T>\r\nclass SegmentTree\r\n{\r\n    int n;\r\n    vector<T> segTree;\r\n\r\npublic:\r\n    SegmentTree() {}\r\n\r\n    SegmentTree(int N)\r\n    {\r\n        n = N;\r\n        segTree.resize(4 * n);\r\n    }\r\n\r\n    void resize(int N)\r\n    {\r\n        n = N;\r\n        segTree.resize(4 * n);\r\n    }\r\n\r\n    void _build_(int si, int ss, int se, T arr[])\r\n    {\r\n        if (ss == se)\r\n        {\r\n            segTree[si] = arr[ss];\r\n        }\r\n        else\r\n        {\r\n            int mid = (ss + se) / 2;\r\n            _build_(2 * si, ss, mid, arr);\r\n            _build_(2 * si + 1, mid + 1, se, arr);\r\n            segTree[si] = max(segTree[2 * si], segTree[2 * si + 1]);\r\n        }\r\n    }\r\n\r\n    void build(T arr[])\r\n    {\r\n        _build_(1, 1, n, arr);\r\n    }\r\n\r\n    T _query_(int si, int ss, int se, int qs, int qe)\r\n    {\r\n        if (qs > se || qe < ss)\r\n            return 0;\r\n        if (qs <= ss && qe >= se)\r\n            return segTree[si];\r\n        int mid = (ss + se) / 2;\r\n        return max(_query_(2 * si, ss, mid, qs, qe), _query_(2 * si + 1, mid + 1, se, qs, qe));\r\n    }\r\n\r\n    T _query_(int si, int ss, int se, int qi)\r\n    {\r\n        if (ss == se)\r\n            return segTree[si];\r\n        else\r\n        {\r\n            int mid = (ss + se) / 2;\r\n            if (qi <= mid)\r\n                return _query_(2 * si, ss, mid, qi);\r\n            else\r\n                return _query_(2 * si + 1, mid + 1, se, qi);\r\n        }\r\n    }\r\n\r\n    T query(int l, int r)\r\n    {\r\n        return _query_(1, 1, n, l, r);\r\n    }\r\n\r\n    T query(int qi)\r\n    {\r\n        return _query_(1, 1, n, qi);\r\n    }\r\n\r\n    void _update_(int si, int ss, int se, int qi, T val)\r\n    {\r\n        if (ss == se)\r\n        {\r\n            segTree[si] = val;\r\n        }\r\n        else\r\n        {\r\n            int mid = (ss + se) / 2;\r\n            if (qi <= mid)\r\n                _update_(2 * si, ss, mid, qi, val);\r\n            else\r\n                _update_(2 * si + 1, mid + 1, se, qi, val);\r\n            segTree[si] = max(segTree[2 * si], segTree[2 * si + 1]);\r\n        }\r\n    }\r\n\r\n    void update(int qi, T val)\r\n    {\r\n        _update_(1, 1, n, qi, val);\r\n    }\r\n};\r\n\r\nconst int treeNode = 10010;\r\nint level[treeNode], parent[treeNode][20], subSize[treeNode];\r\nvector<pair<int, ll>> tree[treeNode];\r\npair<int, ll> specialChild[treeNode];\r\nint timer, label[treeNode], chainHead[treeNode];\r\nll arr[treeNode];\r\n\r\nclass HeavyLightDecomposition\r\n{\r\n    int n;\r\n    SegmentTree<ll> st;\r\n\r\npublic:\r\n    HeavyLightDecomposition(int N)\r\n    {\r\n        n = N;\r\n        timer = 0;\r\n        REP(i, 1, n)\r\n        tree[i].clear(), chainHead[i] = i;\r\n    }\r\n\r\n    void resize(int N)\r\n    {\r\n        n = N;\r\n        timer = 0;\r\n        REP(i, 1, n)\r\n        tree[i].clear(), chainHead[i] = i;\r\n    }\r\n\r\n    void addEdge(int a, int b, int c)\r\n    {\r\n        tree[a].push_back({b, c});\r\n        tree[b].push_back({a, c});\r\n    }\r\n\r\n    void dfs(int node = 1, int par = -1, int l = 0)\r\n    {\r\n        parent[node][0] = par;\r\n        level[node] = l;\r\n        subSize[node] = 1;\r\n\r\n        int nodeX = -1, size = 0;\r\n        ll weight = 0;\r\n\r\n        for (pair<int, ll> child : tree[node])\r\n        {\r\n            if (child.first == par)\r\n                continue;\r\n\r\n            dfs(child.first, node, l + 1);\r\n\r\n            subSize[node] += subSize[child.first];\r\n\r\n            if (size < subSize[child.first])\r\n                size = subSize[child.first], nodeX = child.first, weight = child.second;\r\n        }\r\n\r\n        // special child calculation\r\n        specialChild[node] = {nodeX, weight};\r\n    }\r\n\r\n    int LCA(int a, int b)\r\n    {\r\n        if (level[a] < level[b])\r\n            swap(a, b);\r\n\r\n        int d = level[a] - level[b];\r\n\r\n        while (d)\r\n        {\r\n            int i = log2(d);\r\n            a = parent[a][i];\r\n            d -= 1 << i;\r\n        }\r\n\r\n        if (a == b)\r\n            return a;\r\n\r\n        for (int i = 19; i >= 0; i--)\r\n        {\r\n            if (parent[a][i] != -1 && parent[a][i] != parent[b][i])\r\n                a = parent[a][i], b = parent[b][i];\r\n        }\r\n\r\n        return parent[a][0];\r\n    }\r\n\r\n    // heavy light decomposition part\r\n    void HLD(int node = 1, int par = -1, ll val = 0)\r\n    {\r\n        label[node] = ++timer;\r\n        arr[timer] = val;\r\n\r\n        int sc = specialChild[node].first;\r\n\r\n        if (sc != -1)\r\n        {\r\n            chainHead[sc] = chainHead[node];\r\n            HLD(sc, node, specialChild[node].second);\r\n        }\r\n\r\n        for (pii child : tree[node])\r\n        {\r\n            if (child.first == sc || child.first == par)\r\n                continue;\r\n            HLD(child.first, node, child.second);\r\n        }\r\n    }\r\n\r\n    void init()\r\n    {\r\n        dfs();\r\n\r\n        for (int j = 1; j < 20; j++)\r\n        {\r\n            for (int i = 1; i <= n; i++)\r\n            {\r\n                if (parent[i][j - 1] == -1)\r\n                    parent[i][j] = -1;\r\n                else\r\n                    parent[i][j] = parent[parent[i][j - 1]][j - 1];\r\n            }\r\n        }\r\n\r\n        HLD();\r\n        st.resize(timer);\r\n        st.build(arr);\r\n    }\r\n\r\n    int kAncestor(int a, int d)\r\n    {\r\n        while (d)\r\n        {\r\n            int i = log2(d);\r\n            a = parent[a][i];\r\n            d -= 1 << i;\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    ll queryHLD(int node, int ances)\r\n    {\r\n        ll res = 0, top = 0;\r\n\r\n        while (level[node] > level[ances])\r\n        {\r\n            top = chainHead[node];\r\n\r\n            if (level[top] <= level[ances])\r\n                top = kAncestor(node, level[node] - level[ances] - 1);\r\n\r\n            res = max(res, st.query(label[top], label[node]));\r\n            node = parent[top][0];\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    ll query(int a, int b)\r\n    {\r\n        int lca = LCA(a, b);\r\n        if (level[a] > level[b])\r\n            swap(a, b);\r\n        ll ans = queryHLD(b, lca);\r\n        if (lca == a)\r\n            return ans;\r\n        ans = max(ans, queryHLD(a, lca));\r\n        return ans;\r\n    }\r\n\r\n    void update(int node, ll w)\r\n    {\r\n        int lab = label[node];\r\n        st.update(lab, w);\r\n        arr[lab] = w;\r\n    }\r\n};\r\n\r\nvoid solve()\r\n{\r\n    int n;\r\n    cin >> n;\r\n\r\n    HeavyLightDecomposition hld(n);\r\n\r\n    REP(i, 1, n - 1)\r\n    {\r\n        int a, b, c;\r\n        cin >> a >> b >> c;\r\n        hld.addEdge(a, b, c);\r\n    }\r\n\r\n    hld.init();\r\n\r\n    while (true)\r\n    {\r\n        string s;\r\n        cin >> s;\r\n\r\n        if (s[0] == 'D')\r\n            return;\r\n        else if (s[0] == 'Q')\r\n        {\r\n            int a, b;\r\n            cin >> a >> b;\r\n            cout << hld.query(a, b) << endl;\r\n        }\r\n        else\r\n        {\r\n            ll node, val;\r\n            hld.update(node, val);\r\n        }\r\n    }\r\n}"
    ],
    "description": "Heavy Light Decomposition"
  }
}
