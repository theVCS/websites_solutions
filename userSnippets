{
  "boilerplate": {
    "prefix": "boilerplate code",
    "body": [
      "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long int\r\n#define pii pair<int, int>\r\n#define REP(i, a, b) for (int i = a; i <= b; i++)\r\n#define RREP(i, a, b) for (int i = a; i >= b; i--)\r\n#define endl \"\\n\"\r\n#define all(x) (x).begin(), (x).end()\r\n#define pi 3.141592653589793238\r\n\r\n#define maxN 1000001\r\n#define INF 1000000000\r\n#define mod 1000000007\r\n#define printd(x) cout << fixed << setprecision(10) << x\r\n// int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\r\n// int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\r\n// int dx[] = {-1, 0, 1, 0, 1, -1, 1, -1};\r\n// int dy[] = {0, -1, 0, 1, -1, -1, 1, 1};\r\n\r\nvoid solve()\r\n{\r\n\t$2\r\n}\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\r\n\t// freopen(\"input.txt\",\"r\",stdin);\r\n\t// freopen(\"output.txt\",\"w\",stdout);\r\n\r\n\tint t = 1;\r\n\r\n\t// cin >> t;\r\n\r\n\tREP(tc, 1, t)\r\n\t{\r\n\t\t// cout<<\"Case \"<<tc<<\":\"<<endl;\r\n\t\tsolve();\r\n\t}\r\n\r\n\treturn 0;\r\n}"
    ],
    "description": "this is a boiler plate"
  },
  "FenwickTree": {
    "prefix": "FenwickTree",
    "body": [
      "template <class T>\r\nclass FenwickTree\r\n{\r\n\tint n, LOGN;\r\n\tvector<T> BIT;\r\n\r\npublic:\r\n\tFenwickTree() {}\r\n\r\n\tFenwickTree(int N)\r\n\t{\r\n\t\tLOGN = log2(N);\r\n\t\tn = N;\r\n\t\tBIT.assign(n + 1, 0);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tLOGN = log2(N);\r\n\t\tn = N;\r\n\t\tBIT.assign(n + 1, 0);\r\n\t}\r\n\r\n\tT query(int index)\r\n\t{\r\n\t\tT q = 0;\r\n\r\n\t\twhile (index > 0)\r\n\t\t{\r\n\t\t\tq += BIT[index];\r\n\t\t\tindex -= (index & -index);\r\n\t\t}\r\n\r\n\t\treturn q;\r\n\t}\r\n\r\n\tvoid update(int index, T val)\r\n\t{\r\n\t\twhile (index <= n)\r\n\t\t{\r\n\t\t\tBIT[index] += val;\r\n\t\t\tindex += (index & -index);\r\n\t\t}\r\n\t}\r\n\r\n\tT query(int l, int r)\r\n\t{\r\n\t\treturn query(r) - query(l - 1);\r\n\t}\r\n\r\n\tvoid update(int l, int r, int val)\r\n\t{\r\n\t\tupdate(l, val);\r\n\t\tupdate(r + 1, -val);\r\n\t}\r\n\r\n\tint lowerBound(T val)\r\n\t{\r\n\t\t// will find the lower bound index of val in BIT if monotonically increasing\r\n\t\t// https://codeforces.com/blog/entry/61364\r\n\r\n\t\tT q = 0;\r\n\t\tint pos = 0;\r\n\r\n\t\tfor (int i = LOGN; i >= 0; i--)\r\n\t\t{\r\n\t\t\tif (pos + (1 << i) <= n && q + BIT[pos + (1 << i)] < val)\r\n\t\t\t{\r\n\t\t\t\tq += BIT[pos + (1 << i)];\r\n\t\t\t\tpos += (1 << i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn pos + 1;\r\n\t}\r\n};"
    ],
    "description": "FenwickTree"
  },
  "FenwickTree2D": {
    "prefix": "FenwickTree2D",
    "body": [
      "template <class T>\r\nclass FenwickTree2D\r\n{\r\n\tint n, m;\r\n\tvector<vector<T>> BIT;\r\n\r\npublic:\r\n\tFenwickTree2D() {}\r\n\r\n\tFenwickTree2D(int N, int M)\r\n\t{\r\n\t\tn = N;\r\n\t\tm = M;\r\n\t\tBIT.resize(n + 1);\r\n\r\n\t\tfor (vector<T> &vec : BIT)\r\n\t\t\tvec.assign(m + 1, 0);\r\n\t}\r\n\r\n\tvoid resize(int N, int M)\r\n\t{\r\n\t\tn = N;\r\n\t\tm = M;\r\n\t\tBIT.resize(n + 1);\r\n\r\n\t\tfor (vector<T> &vec : BIT)\r\n\t\t\tvec.assign(m + 1, 0);\r\n\t}\r\n\r\n\tT _query_(int x, int y)\r\n\t{\r\n\t\tT sum = 0;\r\n\r\n\t\tfor (int i = x; i > 0; i -= (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j > 0; j -= (j & -j))\r\n\t\t\t{\r\n\t\t\t\tsum += BIT[i][j]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tT query(int x2, int y2, int x1, int y1)\r\n\t{\r\n\t\treturn _query_(x2, y2) - _query_(x1 - 1, y2) - _query_(x2, y1 - 1) + _query_(x1 - 1, y1 - 1);\r\n\t}\r\n\r\n\tvoid update(int x, int y, T val)\r\n\t{\r\n\t\tfor (int i = x; i <= n; i += (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j <= m; j += (j & -j))\r\n\t\t\t{\r\n\t\t\t\tBIT[i][j] += val;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};"
    ],
    "description": "FenwickTree2D"
  },
  "FenwickTree3D": {
    "prefix": "FenwickTree3D",
    "body": [
      "template <class T>\r\nclass FenwickTree3D\r\n{\r\n\tint l, m, n;\r\n\tvector<vector<vector<T>>> BIT;\r\n\r\npublic:\r\n\tFenwickTree3D() {}\r\n\r\n\tFenwickTree3D(int L, int M, int N)\r\n\t{\r\n\t\tl = L;\r\n\t\tm = M;\r\n\t\tn = N;\r\n\r\n\t\tBIT.resize(l + 1);\r\n\r\n\t\tREP(i, 0, l)\r\n\t\t{\r\n\t\t\tBIT[i].resize(m + 1);\r\n\t\t\tREP(j, 0, m)\r\n\t\t\tBIT[i][j].assign(n + 1, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid resize(int L, int M, int N)\r\n\t{\r\n\t\tl = L;\r\n\t\tm = M;\r\n\t\tn = N;\r\n\r\n\t\tBIT.resize(l + 1);\r\n\r\n\t\tREP(i, 0, l)\r\n\t\t{\r\n\t\t\tBIT[i].resize(m + 1);\r\n\t\t\tREP(j, 0, m)\r\n\t\t\tBIT[i][j].assign(n + 1, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tT _query_(int x, int y, int z)\r\n\t{\r\n\t\tT sum = 0;\r\n\r\n\t\tfor (int i = x; i > 0; i -= (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j > 0; j -= (j & -j))\r\n\t\t\t{\r\n\t\t\t\tfor (int k = z; k > 0; k -= (k & -k))\r\n\t\t\t\t{\r\n\t\t\t\t\tsum += BIT[i][j][k];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tT query(int x2, int y2, int z2, int x1, int y1, int z1)\r\n\t{\r\n\t\treturn _query_(x2, y2, z2) - _query_(x1 - 1, y2, z2) - _query_(x2, y1 - 1, z2) - _query_(x2, y2, z1 - 1) - _query_(x1 - 1, y1 - 1, z1 - 1) + _query_(x1 - 1, y1 - 1, z2) + _query_(x1 - 1, y2, z1 - 1) + _query_(x2, y1 - 1, z1 - 1);\r\n\t}\r\n\r\n\tvoid update(int x, int y, int z, T val)\r\n\t{\r\n\t\tfor (int i = x; i <= l; i += (i & -i))\r\n\t\t{\r\n\t\t\tfor (int j = y; j <= m; j += (j & -j))\r\n\t\t\t{\r\n\t\t\t\tfor (int k = z; k <= n; k += (k & -k))\r\n\t\t\t\t{\r\n\t\t\t\t\tBIT[i][j][k] += val;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};"
    ],
    "description": "FenwickTree3D"
  },
  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "template <class T>\r\nclass SegmentTree\r\n{\r\n\tint n;\r\n\tvector<T> segTree;\r\n\r\npublic:\r\n\tSegmentTree() {}\r\n\r\n\tSegmentTree(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t}\r\n\r\n\tvoid _build_(int si, int ss, int se, T arr[])\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si] = arr[ss];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\t_build_(2 * si, ss, mid, arr);\r\n\t\t\t_build_(2 * si + 1, mid + 1, se, arr);\r\n\t\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid build(T arr[])\r\n\t{\r\n\t\t_build_(1, 1, n, arr);\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qs, int qe)\r\n\t{\r\n\t\tif (qs > se || qe < ss)\r\n\t\t\treturn 0;\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t\treturn segTree[si];\r\n\t\tint mid = (ss + se) / 2;\r\n\t\treturn _query_(2 * si, ss, mid, qs, qe) + _query_(2 * si + 1, mid + 1, se, qs, qe);\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qi)\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t\treturn segTree[si];\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\tif (qi <= mid)\r\n\t\t\t\treturn _query_(2 * si, ss, mid, qi);\r\n\t\t\telse\r\n\t\t\t\treturn _query_(2 * si + 1, mid + 1, se, qi);\r\n\t\t}\r\n\t}\r\n\r\n\tT query(int l, int r)\r\n\t{\r\n\t\treturn _query_(1, 1, n, l, r);\r\n\t}\r\n\r\n\tT query(int qi)\r\n\t{\r\n\t\treturn _query_(1, 1, n, qi);\r\n\t}\r\n\r\n\tvoid _update_(int si, int ss, int se, int qi, T val)\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si] = val;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\tif (qi <= mid)\r\n\t\t\t\t_update_(2 * si, ss, mid, qi, val);\r\n\t\t\telse\r\n\t\t\t\t_update_(2 * si + 1, mid + 1, se, qi, val);\r\n\t\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid update(int qi, T val)\r\n\t{\r\n\t\t_update_(1, 1, n, qi, val);\r\n\t}\r\n};"
    ],
    "description": "SegmentTree"
  },
  "SegmentTreeLazyPropogation": {
    "prefix": "SegmentTreeLazyPropogation",
    "body": [
      "template <class T>\r\nclass SegmentTreeLazyPropogation\r\n{\r\n\tint n;\r\n\tvector<T> segTree;\r\n\tvector<T> lazy;\r\n\r\npublic:\r\n\tSegmentTreeLazyPropogation(){}\r\n\t\r\n\tSegmentTreeLazyPropogation(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t\tlazy.assign(4 * n, 0);\r\n\t}\r\n\r\n\tint resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tsegTree.resize(4 * n);\r\n\t\tlazy.assign(4 * n, 0);\r\n\t}\r\n\r\n\tvoid _build_(int si, int ss, int se, T arr[])\r\n\t{\r\n\t\tif (ss == se)\r\n\t\t{\r\n\t\t\tsegTree[si] = arr[ss];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tint mid = (ss + se) / 2;\r\n\t\t\t_build_(2 * si, ss, mid, arr);\r\n\t\t\t_build_(2 * si + 1, mid + 1, se, arr);\r\n\t\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid build(T arr[])\r\n\t{\r\n\t\t_build_(1, 1, n, arr);\r\n\t}\r\n\r\n\tT _query_(int si, int ss, int se, int qs, int qe)\r\n\t{\r\n\t\tif (lazy[si])\r\n\t\t{\r\n\t\t\tsegTree[si] += (se - ss + 1) * lazy[si];\r\n\r\n\t\t\tif (ss != se)\r\n\t\t\t\tlazy[2 * si] += lazy[si], lazy[2 * si + 1] += lazy[si];\r\n\r\n\t\t\tlazy[si] = 0;\r\n\t\t}\r\n\r\n\t\tif (qs > se || qe < ss)\r\n\t\t\treturn 0;\r\n\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t\treturn segTree[si];\r\n\r\n\t\tint mid = (ss + se) / 2;\r\n\t\treturn _query_(2 * si, ss, mid, qs, qe) + _query_(2 * si + 1, mid + 1, se, qs, qe);\r\n\t}\r\n\r\n\tT query(int l, int r=-1)\r\n\t{\r\n\t\tif(r==-1)r=l;\r\n\t\treturn _query_(1, 1, n, l, r);\r\n\t}\r\n\r\n\tvoid _update_(int si, int ss, int se, int qs, int qe, T val)\r\n\t{\r\n\t\tif (lazy[si])\r\n\t\t{\r\n\t\t\tsegTree[si] += (se - ss + 1) * lazy[si];\r\n\r\n\t\t\tif (ss != se)\r\n\t\t\t\tlazy[2 * si] += lazy[si], lazy[2 * si + 1] += lazy[si];\r\n\r\n\t\t\tlazy[si] = 0;\r\n\t\t}\r\n\r\n\t\tif (ss > qe || se < qs)\r\n\t\t\treturn;\r\n\r\n\t\tif (qs <= ss && qe >= se)\r\n\t\t{\r\n\t\t\tsegTree[si] += (se - ss + 1) * val;\r\n\r\n\t\t\tif (ss != se)\r\n\t\t\t\tlazy[2 * si] += val, lazy[2 * si + 1] += val;\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint mid = (ss + se) / 2;\r\n\r\n\t\t_update_(2 * si, ss, mid, qs, qe, val);\r\n\t\t_update_(2 * si + 1, mid + 1, se, qs, qe, val);\r\n\r\n\t\tsegTree[si] = segTree[2 * si] + segTree[2 * si + 1];\r\n\t}\r\n\r\n\tvoid update(int l, int r, T val)\r\n\t{\r\n\t\t_update_(1, 1, n, l, r, val);\r\n\t}\r\n};"
    ],
    "description": "SegmentTreeLazyPropogation"
  },
  "mergeSortTree": {
    "prefix": "mergeSortTree",
    "body": [
      "const int arrSize = 30001;\r\nint arr[arrSize];\r\n\r\ntemplate <class T>\r\nclass mergeSortTree\r\n{\r\n    int n;\r\n    vector<T> segTree[4 * arrSize];\r\n\r\npublic:\r\n    mergeSortTree() {}\r\n\r\n    mergeSortTree(int N)\r\n    {\r\n        n = N;\r\n    }\r\n\r\n    void resize(int N)\r\n    {\r\n        n = N;\r\n    }\r\n\r\n    void _build_(int si, int ss, int se)\r\n    {\r\n        if (ss == se)\r\n        {\r\n            segTree[si].push_back(arr[ss]);\r\n        }\r\n        else\r\n        {\r\n            int mid = (ss + se) / 2;\r\n\r\n            _build_(2 * si, ss, mid);\r\n            _build_(2 * si + 1, mid + 1, se);\r\n\r\n            int i = 0, j = 0;\r\n\r\n            while (i < segTree[2 * si].size() && j < segTree[2 * si + 1].size())\r\n                if (segTree[2 * si][i] < segTree[2 * si + 1][j])\r\n                    segTree[si].push_back(segTree[2 * si][i++]);\r\n                else\r\n                    segTree[si].push_back(segTree[2 * si + 1][j++]);\r\n\r\n            while (i < segTree[2 * si].size())\r\n                segTree[si].push_back(segTree[2 * si][i++]);\r\n\r\n            while (j < segTree[2 * si + 1].size())\r\n                segTree[si].push_back(segTree[2 * si + 1][j++]);\r\n        }\r\n    }\r\n\r\n    void build()\r\n    {\r\n        _build_(1, 1, n);\r\n    }\r\n\r\n    int bs(int si, T val)\r\n    {\r\n        int start = 0, end = segTree[si].size() - 1;\r\n\r\n        while (start <= end)\r\n        {\r\n            int mid = (start + end) / 2;\r\n\r\n            if (segTree[si][mid] <= val && (mid == end || segTree[si][mid + 1] > val))\r\n                return segTree[si].size() - 1 - mid;\r\n            else if (segTree[si][mid] <= val)\r\n                start = mid + 1;\r\n            else\r\n                end = mid - 1;\r\n        }\r\n\r\n        return segTree[si].size();\r\n    }\r\n\r\n    T _query_(int si, int ss, int se, int qs, int qe, T val)\r\n    {\r\n        if (qs > se || qe < ss)\r\n            return 0;\r\n\r\n        if (qs <= ss && qe >= se)\r\n            return bs(si, val);\r\n\r\n        int mid = (ss + se) / 2;\r\n\r\n        return _query_(2 * si, ss, mid, qs, qe, val) + _query_(2 * si + 1, mid + 1, se, qs, qe, val);\r\n    }\r\n\r\n    T query(int l, int r, T val)\r\n    {\r\n        return _query_(1, 1, n, l, r, val);\r\n    }\r\n};"
    ],
    "description": "mergeSortTree"
  },
  "PersistentSegmentTree": {
    "prefix": "PersistentSegmentTree",
    "body": [
      "template <class T>\r\nclass PersistentSegmentTree\r\n{\r\n    int n;\r\n    vector<T> segTree;\r\n    vector<int> left, right;\r\n    vector<int> roots;\r\n    int index;\r\n\r\npublic:\r\n    PersistentSegmentTree() {}\r\n\r\n    int build(int ss, int se)\r\n    {\r\n        int node = ++index;\r\n\r\n        if (ss == se)\r\n        {\r\n            segTree[node] = 0;\r\n            return node;\r\n        }\r\n        else\r\n        {\r\n            int mid = (ss + se) / 2;\r\n            left[node] = build(ss, mid);\r\n            right[node] = build(mid + 1, se);\r\n            segTree[node] = 0;\r\n            return node;\r\n        }\r\n    }\r\n\r\n    PersistentSegmentTree(int N)\r\n    {\r\n        n = N;\r\n        segTree.resize(N * 21);\r\n        left.resize(N * 21);\r\n        right.resize(N * 21);\r\n        index = 0;\r\n        roots.push_back(build(1, n));\r\n    }\r\n\r\n    void resize(int N)\r\n    {\r\n        n = N;\r\n        segTree.resize(N * 21);\r\n        left.resize(N * 21);\r\n        right.resize(N * 21);\r\n        index = 0;\r\n        roots.push_back(build(1, n));\r\n    }\r\n\r\n    int _update_(int prevNode, int ss, int se, int qi, T val)\r\n    {\r\n        int node = ++index;\r\n\r\n        if (ss == se)\r\n        {\r\n            segTree[node] = segTree[prevNode] + val;\r\n            return node;\r\n        }\r\n\r\n        int mid = (ss + se) / 2;\r\n\r\n        if (qi <= mid)\r\n        {\r\n            right[node] = right[prevNode];\r\n            left[node] = _update_(left[prevNode], ss, mid, qi, val);\r\n        }\r\n        else\r\n        {\r\n            left[node] = left[prevNode];\r\n            right[node] = _update_(right[prevNode], mid + 1, se, qi, val);\r\n        }\r\n\r\n        segTree[node] = segTree[left[node]] + segTree[right[node]];\r\n        return node;\r\n    }\r\n\r\n    void update(int index, T val)\r\n    {\r\n        roots.push_back(_update_(roots.back(), 1, n, index, val));\r\n    }\r\n\r\n    T _query_(int nodeA, int nodeB, int ss, int se, int qs, int qe)\r\n    {\r\n        if (qs > se || qe < ss)\r\n            return 0;\r\n        if (qs <= ss && qe >= se)\r\n            return segTree[nodeA] - segTree[nodeB];\r\n        int mid = (ss + se) / 2;\r\n        return _query_(left[nodeA], left[nodeB], ss, mid, qs, qe) + _query_(right[nodeA], right[nodeB], mid + 1, se, qs, qe);\r\n    }\r\n\r\n    T _query_(int nodeA, int nodeB, int ss, int se, int k)\r\n    {\r\n        if (ss == se)\r\n            return ss;\r\n\r\n        int diff = segTree[left[nodeA]] - segTree[left[nodeB]];\r\n        int mid = (ss + se) / 2;\r\n\r\n        if (diff >= k)\r\n            return _query_(left[nodeA], left[nodeB], ss, mid, k);\r\n        else\r\n            return _query_(right[nodeA], right[nodeB], mid + 1, se, k - diff);\r\n    }\r\n\r\n    T query(int ul, int ur, int qs, int qe = -1)\r\n    {\r\n        if (qe == -1)\r\n            return _query_(roots[ur], roots[ul - 1], 1, n, qs);\r\n        else\r\n            return _query_(roots[ur], roots[ul - 1], 1, n, qs, qe);\r\n    }\r\n};\r\n"
    ],
    "description": "PersistentSegmentTree"
  },
  "DSU": {
    "prefix": "DSU",
    "body": [
      "class DSU\r\n{\r\n\tint n;\r\n\tvector<int> par;\r\n\r\npublic:\r\n\tDSU(){}\r\n\r\n\tDSU(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tpar.assign(n + 1, -1);\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t\tpar.assign(n + 1, -1);\r\n\t}\r\n\r\n\tint find(int a)\r\n\t{\r\n\t\tif (par[a] < 0)\r\n\t\t\treturn a;\r\n\t\telse\r\n\t\t\treturn par[a] = find(par[a]);\r\n\t}\r\n\r\n\tvoid merger(int a, int b)\r\n\t{\r\n\t\ta = find(a);\r\n\t\tb = find(b);\r\n\r\n\t\tif(a==b)return;\r\n\r\n\t\tif (par[a] > par[b])\r\n\t\t\tswap(a, b);\r\n\r\n\t\tpar[a] += par[b];\r\n\t\tpar[b] = a;\r\n\t}\r\n};"
    ],
    "description": "DSU"
  },
  "MO": {
    "prefix": "MO",
    "body": [
      "const int arrSize = 100001;\r\nint arr[arrSize];\r\n\r\ntemplate <class T>\r\nclass MO\r\n{\r\n\tstruct Query\r\n\t{\r\n\t\tint l, r, index;\r\n\t\tll order;\r\n\r\n\t\tQuery(int _l, int _r, int _index)\r\n\t\t{\r\n\t\t\tl = _l;\r\n\t\t\tr = _r;\r\n\t\t\tindex = _index;\r\n\t\t\torder = gilbertOrder(l, r, 21, 0);\r\n\t\t}\r\n\r\n\t\tinline int64_t gilbertOrder(int x, int y, int pow, int rotate)\r\n\t\t{\r\n\t\t\tif (pow == 0)\r\n\t\t\t{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tint hpow = 1 << (pow - 1);\r\n\t\t\tint seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ((y < hpow) ? 1 : 2);\r\n\t\t\tseg = (seg + rotate) & 3;\r\n\t\t\tconst int rotateDelta[4] = {3, 0, 0, 1};\r\n\t\t\tint nx = x & (x ^ hpow), ny = y & (y ^ hpow);\r\n\t\t\tint nrot = (rotate + rotateDelta[seg]) & 3;\r\n\t\t\tint64_t subSquareSize = int64_t(1) << (2 * pow - 2);\r\n\t\t\tint64_t ans = seg * subSquareSize;\r\n\t\t\tint64_t add = gilbertOrder(nx, ny, pow - 1, nrot);\r\n\t\t\tans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);\r\n\t\t\treturn ans;\r\n\t\t}\r\n\t};\r\n\r\n\tint n, q;\r\n\tT res;\r\n\tvector<T> fre, ans;\r\n\tvector<Query> Q;\r\n\r\npublic:\r\n\tMO() {}\r\n\r\n\t// N -> no of elements, Q -> no of queries, R -> range of elements\r\n\tMO(int N, int Q, int R)\r\n\t{\r\n\t\tn = N;\r\n\t\tq = Q;\r\n\t\tres = 0;\r\n\t\tfre.assign(R + 1, 0);\r\n\t\tans.resize(Q + 1);\r\n\t}\r\n\r\n\tvoid resize(int N, int Q, int R)\r\n\t{\r\n\t\tn = N;\r\n\t\tq = Q;\r\n\t\tres = 0;\r\n\t\tfre.assign(R + 1, 0);\r\n\t\tans.resize(Q + 1);\r\n\t}\r\n\r\n\tvoid addQuery(int l, int r, int index)\r\n\t{\r\n\t\tQ.push_back(Query(l, r, index));\r\n\t}\r\n\r\n\tvoid add(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\r\n\t\tif (++fre[ele] == 1)\r\n\t\t\tres++;\r\n\t}\r\n\r\n\tvoid remove(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\r\n\t\tif (--fre[ele] == 0)\r\n\t\t\tres--;\r\n\t}\r\n\r\n\tvoid processQuery()\r\n\t{\r\n\t\tsort(all(Q), [](const Query &lhs, const Query &rhs)\r\n\t\t\t { return lhs.order < rhs.order; });\r\n\r\n\t\tfor (int i = 0, L = 1, R = 0; i < q; i++)\r\n\t\t{\r\n\t\t\twhile (R < Q[i].r)\r\n\t\t\t\tadd(++R);\r\n\t\t\twhile (L > Q[i].l)\r\n\t\t\t\tadd(--L);\r\n\t\t\twhile (R > Q[i].r)\r\n\t\t\t\tremove(R--);\r\n\t\t\twhile (L < Q[i].l)\r\n\t\t\t\tremove(L++);\r\n\r\n\t\t\tans[Q[i].index] = res;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid showAns()\r\n\t{\r\n\t\tREP(i, 1, q)\r\n\t\t{\r\n\t\t\tcout << ans[i] << endl;\r\n\t\t}\r\n\t}\r\n};"
    ],
    "description": "MO"
  },
  "MOWithUpdate": {
    "prefix": "MOWithUpdate",
    "body": [
      "const int blk = 2100;\r\nconst int arrSize = 100001;\r\nconst int querSize = 100001;\r\nconst int freSize = 200001;\r\n\r\nstruct Query\r\n{\r\n\tint l, r, t, index;\r\n} q[querSize];\r\n\r\nstruct Update\r\n{\r\n\tint index, new_y, prev_y;\r\n} u[querSize];\r\n\r\nbool cmp(Query const &a, Query const &b)\r\n{\r\n\tif (a.t / blk != b.t / blk)\r\n\t\treturn a.t < b.t;\r\n\tif (a.l / blk != b.l / blk)\r\n\t\treturn a.l < b.l;\r\n\treturn a.r < b.r;\r\n}\r\n\r\nint arr[arrSize];  // array which contains main data\r\nint last[arrSize]; // last element present in the vector\r\nbool use[arrSize]; // used in update\r\nint fre[freSize];  // use to keep track of no of elements\r\n\r\n// extra variables\r\nint ff[arrSize];\r\nmap<int, int> mp;\r\n\r\ntemplate <class TYPE>\r\nclass MOWithUpdate\r\n{\r\n\tint n, m;\r\n\tint nq, nu;\r\n\tTYPE res;\r\n\tvector<TYPE> ans;\r\n\r\npublic:\r\n\tMOWithUpdate() {}\r\n\r\n\tMOWithUpdate(int N, int M)\r\n\t{\r\n\t\tn = N, m = M;\r\n\t\tnq = nu = res = 0;\r\n\t\tans.resize(M + 1);\r\n\t}\r\n\r\n\tvoid resize(int N, int M)\r\n\t{\r\n\t\tn = N, m = M;\r\n\t\tnq = nu = res = 0;\r\n\t\tans.resize(M + 1);\r\n\t}\r\n\r\n\tvoid addQuery(int a, int b)\r\n\t{\r\n\t\tnq++;\r\n\t\tq[nq].l = a;\r\n\t\tq[nq].r = b;\r\n\t\tq[nq].index = nq;\r\n\t\tq[nq].t = nu;\r\n\t}\r\n\r\n\tvoid addUpdate(int index, TYPE val)\r\n\t{\r\n\t\tnu++;\r\n\t\tu[nu].index = index;\r\n\t\tu[nu].new_y = val;\r\n\t\tu[nu].prev_y = last[index];\r\n\t\tlast[index] = val;\r\n\t}\r\n\r\n\tvoid add(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\t\tuse[index] = true;\r\n\r\n\t\t--ff[fre[ele]];\r\n\t\t++fre[ele];\r\n\t\t++ff[fre[ele]];\r\n\t}\r\n\r\n\tvoid remove(int index)\r\n\t{\r\n\t\tll ele = arr[index];\r\n\t\tuse[index] = false;\r\n\r\n\t\t--ff[fre[ele]];\r\n\t\t--fre[ele];\r\n\t\t++ff[fre[ele]];\r\n\t}\r\n\r\n\tvoid reflect_update(int index, int ele)\r\n\t{\r\n\t\tif (use[index] == false)\r\n\t\t{\r\n\t\t\tarr[index] = ele;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tremove(index);\r\n\t\tarr[index] = ele;\r\n\t\tadd(index);\r\n\t}\r\n\r\n\tvoid do_update(int index)\r\n\t{\r\n\t\treflect_update(u[index].index, u[index].new_y);\r\n\t}\r\n\r\n\tvoid undo(int index)\r\n\t{\r\n\t\treflect_update(u[index].index, u[index].prev_y);\r\n\t}\r\n\r\n\tint getAns()\r\n\t{\r\n\t\tREP(i, 1, 600)\r\n\t\tif (ff[i] == 0)\r\n\t\t\treturn i;\r\n\t}\r\n\r\n\tvoid processQueries()\r\n\t{\r\n\t\tsort(q + 1, q + nq + 1, cmp);\r\n\r\n\t\tfor (int i = 1, L = 2, R = 1, T = 0; i <= nq; i++)\r\n\t\t{\r\n\t\t\twhile (T < q[i].t)\r\n\t\t\t\tdo_update(++T);\r\n\t\t\twhile (T > q[i].t)\r\n\t\t\t\tundo(T--);\r\n\t\t\twhile (R < q[i].r)\r\n\t\t\t\tadd(++R);\r\n\t\t\twhile (L > q[i].l)\r\n\t\t\t\tadd(--L);\r\n\t\t\twhile (R > q[i].r)\r\n\t\t\t\tremove(R--);\r\n\t\t\twhile (L < q[i].l)\r\n\t\t\t\tremove(L++);\r\n\r\n\t\t\tans[q[i].index] = getAns();\r\n\t\t}\r\n\t}\r\n\r\n\tvoid showAns()\r\n\t{\r\n\t\tREP(i, 1, nq)\r\n\t\t\tcout << ans[i] << endl;\r\n\t}\r\n\r\n\tvoid preprocess()\r\n\t{\r\n\t\tint timer = 0;\r\n\r\n\t\tfor (auto &e : mp)\r\n\t\t\te.second = ++timer;\r\n\r\n\t\tREP(i, 1, n)\r\n\t\tarr[i] = mp[arr[i]];\r\n\r\n\t\tREP(i, 1, nu)\r\n\t\tu[i].new_y = mp[u[i].new_y],\r\n\t\tu[i].prev_y = mp[u[i].prev_y];\r\n\t}\r\n};\r\n\r\nvoid solve()\r\n{\r\n\tint n, m;\r\n\tcin >> n >> m;\r\n\r\n\tMOWithUpdate<int> mo(n, m);\r\n\r\n\tREP(i, 1, n)\r\n\t{\r\n\t\tcin >> arr[i];\r\n\t\tlast[i] = arr[i];\r\n\t\tmp[arr[i]];\r\n\t}\r\n\r\n\tREP(i, 1, m)\r\n\t{\r\n\t\tint type, a, b;\r\n\t\tcin >> type >> a >> b;\r\n\r\n\t\tif (type == 1)\r\n\t\t{\r\n\t\t\tmo.addQuery(a, b);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmp[b];\r\n\t\t\tmo.addUpdate(a, b);\r\n\t\t}\r\n\t}\r\n\r\n\tmo.preprocess();\r\n\tmo.processQueries();\r\n\tmo.showAns();\r\n}"
    ],
    "description": "MOWithUpdate"
  },
  "Tree": {
    "prefix": "Tree",
    "body": [
      "const int treeNode = 100001;\r\nvector<int> tree[treeNode];\r\n\r\n// for lca finding\r\nint level[treeNode], parent[treeNode][19];\r\n\r\n// euler tree tour technique\r\nint FT[2 * treeNode], intime[treeNode], outime[treeNode], timer;\r\n\r\nclass Tree\r\n{\r\n\tint n;\r\n\r\npublic:\r\n\tTree() {}\r\n\r\n\tTree(int N)\r\n\t{\r\n\t\tn = N;\r\n\t}\r\n\r\n\tvoid resize(int N)\r\n\t{\r\n\t\tn = N;\r\n\t}\r\n\r\n\tvoid addEdge(int a, int b)\r\n\t{\r\n\t\ttree[a].push_back(b), tree[b].push_back(a);\r\n\t}\r\n\r\n\tvoid euler(int node = 1, int par = -1, int l = 0)\r\n\t{\r\n\t\t// euler tree tour technique\r\n\t\tintime[node] = ++timer;\r\n\t\tFT[timer] = node;\r\n\r\n\t\t// lca\r\n\t\tparent[node][0] = par;\r\n\t\tlevel[node] = l;\r\n\r\n\t\tfor (int child : tree[node])\r\n\t\t{\r\n\t\t\tif (child == par)\r\n\t\t\t\tcontinue;\r\n\t\t\teuler(child, node, l + 1);\r\n\t\t}\r\n\r\n\t\t// euler tree tour technique\r\n\t\toutime[node] = ++timer;\r\n\t\tFT[timer] = node;\r\n\t}\r\n\r\n\tvoid init()\r\n\t{\r\n\t\teuler();\r\n\r\n\t\t// lca portion\r\n\t\tfor (int j = 1; j < 19; j++)\r\n\t\t\tfor (int i = 1; i <= n; i++)\r\n\t\t\t\tif (parent[i][j - 1] == -1)\r\n\t\t\t\t\tparent[i][j] = -1;\r\n\t\t\t\telse\r\n\t\t\t\t\tparent[i][j] = parent[parent[i][j - 1]][j - 1];\r\n\t}\r\n\r\n\tint LCA(int a, int b)\r\n\t{\r\n\t\tif (level[a] < level[b])\r\n\t\t\tswap(a, b);\r\n\r\n\t\tint d = level[a] - level[b];\r\n\r\n\t\twhile (d)\r\n\t\t{\r\n\t\t\tint i = log2(d);\r\n\t\t\ta = parent[a][i];\r\n\t\t\td -= 1 << i;\r\n\t\t}\r\n\r\n\t\tif (a == b)\r\n\t\t\treturn a;\r\n\r\n\t\tfor (int i = 18; i >= 0; i--)\r\n\t\t\tif (parent[a][i] != -1 && parent[a][i] != parent[b][i])\r\n\t\t\t\ta = parent[a][i], b = parent[b][i];\r\n\r\n\t\treturn parent[a][0];\r\n\t}\r\n};"
    ],
    "description": "Tree"
  },
  "sqrtDecomposition": {
    "prefix": "sqrtDecomposition",
    "body": [
      "const int blk = 900;\r\nconst int f_size = 120;\r\nll arr[maxN], f[f_size];\t// f_size = maxN / blk;\r\n\r\nclass sqrtDecomposition\r\n{\r\npublic:\r\n\tvoid init()\r\n\t{\r\n\t\tmemset(f, INT_MAX, sizeof(f));   \r\n\t\t\r\n\t\tREP(i, 1, n)\r\n\t\tf[i / blk] = min(arr[i], f[i / blk]);\r\n\t}\r\n\r\n\tll query(int l, int r)\r\n\t{\r\n\t\tint lblk = l / blk;\r\n\t\tint rblk = r / blk;\r\n\r\n\t\tll res = INT_MAX;\r\n\r\n\t\tif (lblk == rblk)\r\n\t\t{\r\n\t\t\tREP(i, l, r)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, arr[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tREP(i, l, blk * (lblk + 1) - 1)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, arr[i]);\r\n\t\t\t}\r\n\r\n\t\t\tREP(i, lblk + 1, rblk - 1)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, f[i]);\r\n\t\t\t}\r\n\r\n\t\t\tREP(i, rblk * blk, r)\r\n\t\t\t{\r\n\t\t\t\tres = min(res, arr[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n};"
    ],
    "description": "sqrtDecomposition"
  },
  "TrieString": {
    "prefix": "TrieString",
    "body": [
      "const int sz = 26;\r\n\r\nclass TrieString\r\n{\r\n    struct Node\r\n    {\r\n        bool endOfWord;\r\n        Node *arr[sz];\r\n        int cnt;\r\n\r\n        Node()\r\n        {\r\n            endOfWord = false;\r\n            REP(i, 0, sz - 1)\r\n            arr[i] = NULL;\r\n            cnt = 0;\r\n        }\r\n    };\r\n\r\n    Node *root;\r\n\r\npublic:\r\n    TrieString()\r\n    {\r\n        root = new Node();\r\n    }\r\n\r\n    void insert(string &s)\r\n    {\r\n        Node *temp = root;\r\n\r\n        for (char c : s)\r\n        {\r\n            int index = c - 'a';\r\n\r\n            if (temp->arr[index] == NULL)\r\n                temp->arr[index] = new Node();\r\n\r\n            temp = temp->arr[index];\r\n            temp->cnt++;\r\n        }\r\n\r\n        temp->endOfWord = true;\r\n    }\r\n\r\n    bool search(string &s)\r\n    {\r\n        Node *temp = root;\r\n        if(temp==NULL)return false;\r\n\r\n        for (char c : s)\r\n        {\r\n            int index = c - 'a';\r\n\r\n            if (temp->arr[index] == NULL || temp->arr[index]->cnt == 0)\r\n                return false;\r\n\r\n            temp = temp->arr[index];\r\n        }\r\n\r\n        return temp->endOfWord;\r\n    }\r\n\r\n    void del(string &s)\r\n    {\r\n        if (search(s) == false)\r\n            return;\r\n\r\n        Node *temp = root;\r\n\r\n        for (char c : s)\r\n        {\r\n            int index = c - 'a';\r\n            temp = temp->arr[index];\r\n            temp->cnt--;\r\n        }\r\n\r\n        if (temp->cnt == 0)\r\n            temp->endOfWord = false;\r\n    }\r\n};"
    ],
    "description": "TrieString"
  },
  "TrieBit": {
    "prefix": "TrieBit",
    "body": [
      "const int sz = 2;\r\n\r\nclass TrieBit\r\n{\r\n    struct Node\r\n    {\r\n        Node *arr[sz];\r\n        int cnt;\r\n\r\n        Node()\r\n        {\r\n            REP(i, 0, sz - 1)\r\n            arr[i] = NULL;\r\n            cnt = 0;\r\n        }\r\n    };\r\n\r\n    Node *root;\r\n\r\npublic:\r\n    TrieBit()\r\n    {\r\n        root = new Node();\r\n    }\r\n\r\n    void insert(ll s)\r\n    {\r\n        Node *temp = root;\r\n\r\n        RREP(i, 63, 0)\r\n        {\r\n            if (s & (1LL << i))\r\n            {\r\n                if (temp->arr[1] == NULL)\r\n                    temp->arr[1] = new Node();\r\n                temp = temp->arr[1];\r\n            }\r\n            else\r\n            {\r\n                if (temp->arr[0] == NULL)\r\n                    temp->arr[0] = new Node();\r\n                temp = temp->arr[0];\r\n            }\r\n\r\n            temp->cnt++;\r\n        }\r\n    }\r\n\r\n    bool search(ll s)\r\n    {\r\n        Node *temp = root;\r\n        if(temp==NULL)return false;\r\n\r\n        RREP(i, 63, 0)\r\n        {\r\n            if (s & (1LL << i))\r\n            {\r\n                if (temp->arr[1] == NULL || temp->arr[1]->cnt == 0)\r\n                    return false;\r\n                temp = temp->arr[1];\r\n            }\r\n            else\r\n            {\r\n                if (temp->arr[0] == NULL || temp->arr[0]->cnt == 0)\r\n                    return false;\r\n                temp = temp->arr[0];\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    void del(ll s)\r\n    {\r\n        if (search(s) == false)\r\n            return;\r\n\r\n        Node *temp = root;\r\n\r\n        RREP(i, 63, 0)\r\n        {\r\n            if (s & (1LL << i))\r\n            {\r\n                temp = temp->arr[1];\r\n            }\r\n            else\r\n            {\r\n                temp = temp->arr[0];\r\n            }\r\n\r\n            temp->cnt--;\r\n        }\r\n    }\r\n\r\n    ll calc(ll s)\r\n    {\r\n        Node *temp = root;\r\n        ll ans = 0;\r\n\r\n        RREP(i, 63, 0)\r\n        {\r\n            if (s & (1LL << i))\r\n            {\r\n                if (temp->arr[0] && temp->arr[0]->cnt)\r\n                {\r\n                    ans |= (1LL << i);\r\n                    temp = temp->arr[0];\r\n                }\r\n                else\r\n                {\r\n                    temp = temp->arr[1];\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (temp->arr[1] && temp->arr[1]->cnt)\r\n                {\r\n                    ans |= (1LL << i);\r\n                    temp = temp->arr[1];\r\n                }\r\n                else\r\n                {\r\n                    temp = temp->arr[0];\r\n                }\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n"
    ],
    "description": "TrieBit"
  },
  "MaximumConvexHull": {
    "prefix": "MaximumConvexHull",
    "body": [
      "struct Line\r\n{\r\n    mutable ll m, b, p;\r\n    bool operator<(const Line &o) const { return m < o.m; }\r\n    bool operator<(ll x) const { return p < x; }\r\n};\r\n\r\n// for maximum value\r\nstruct LineContainer : multiset<Line, less<>>\r\n{\r\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\r\n    const ll inf = LLONG_MAX;\r\n    \r\n    ll div(ll a, ll b)\r\n    { // floored division\r\n        return a / b - ((a ^ b) < 0 && a % b);\r\n    }\r\n\r\n    bool isect(iterator x, iterator y)\r\n    {\r\n        if (y == end())\r\n        {\r\n            x->p = inf;\r\n            return false;\r\n        }\r\n        if (x->m == y->m)\r\n            x->p = x->b > y->b ? inf : -inf;\r\n        else\r\n            x->p = div(y->b - x->b, x->m - y->m);\r\n        return x->p >= y->p;\r\n    }\r\n    \r\n    void add(ll m, ll b)\r\n    {\r\n        auto z = insert({m, b, 0}), y = z++, x = y;\r\n        while (isect(y, z))\r\n            z = erase(z);\r\n        if (x != begin() && isect(--x, y))\r\n            isect(x, y = erase(y));\r\n        while ((y = x) != begin() && (--x)->p >= y->p)\r\n            isect(x, erase(y));\r\n    }\r\n    \r\n    ll query(ll x)\r\n    {\r\n        assert(!empty());\r\n        auto l = *lower_bound(x);\r\n        return l.m * x + l.b;\r\n    }\r\n} cht;\r\n"
    ],
    "description": "MaximumConvexHull"
  },
  "MinimumConvexHull": {
    "prefix": "MinimumConvexHull",
    "body": [
      "struct Line\r\n{\r\n    mutable ll m, b, p;\r\n    bool operator<(const Line &o) const { return m < o.m; }\r\n    bool operator<(ll x) const { return p < x; }\r\n};\r\n\r\nstruct LineContainer : multiset<Line, less<>>\r\n{\r\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\r\n    const ll inf = LLONG_MAX;\r\n\r\n    ll div(ll a, ll b)\r\n    { // floored division\r\n        return a / b - ((a ^ b) < 0 && a % b);\r\n    }\r\n\r\n    bool isect(iterator x, iterator y)\r\n    {\r\n        if (y == end())\r\n        {\r\n            x->p = inf;\r\n            return false;\r\n        }\r\n        if (x->m == y->m)\r\n            x->p = x->b > y->b ? inf : -inf;\r\n        else\r\n            x->p = div(y->b - x->b, x->m - y->m);\r\n        return x->p >= y->p;\r\n    }\r\n\r\n    void add(ll m, ll b)\r\n    {\r\n        m *= -1, b *= -1;\r\n        auto z = insert({m, b, 0}), y = z++, x = y;\r\n        while (isect(y, z))\r\n            z = erase(z);\r\n        if (x != begin() && isect(--x, y))\r\n            isect(x, y = erase(y));\r\n        while ((y = x) != begin() && (--x)->p >= y->p)\r\n            isect(x, erase(y));\r\n    }\r\n\r\n    ll query(ll x)\r\n    {\r\n        assert(!empty());\r\n        auto l = *lower_bound(x);\r\n        return -1 * (l.m * x + l.b);\r\n    }\r\n} cht;"
    ],
    "description": "MinimumConvexHull"
  },
  "digitDP2Flags": {
    "prefix": "digitDP2Flags",
    "body": [
      "string str1, str2;\r\nll dp[10][2][2][82];\r\nint N;\r\n\r\n// flag1 -> for lower bound\r\n// flag2 -> for upper bound\r\n\r\nll digitDP(int pos, int flag1 = 1, int flag2 = 1, ll res = 0)\r\n{\r\n    if (pos < 0)\r\n        return res;\r\n    else if (dp[pos][flag1][flag2][res] != -1)\r\n        return dp[pos][flag1][flag2][res];\r\n    else\r\n    {\r\n        ll ans = 0;\r\n        int lb = flag1 ? (str1[pos] - '0') : 0;\r\n        int ub = flag2 ? (str2[pos] - '0') : 9;\r\n\r\n        REP(i, lb, ub)\r\n        {\r\n            ans += digitDP(pos - 1, (i == lb & flag1), (i == ub & flag2), res + i);\r\n        }\r\n\r\n        return dp[pos][flag1][flag2][res] = ans;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    cin >> str1 >> str2;\r\n\r\n    if (str1[0] == '-')\r\n    {\r\n        return;\r\n    }\r\n\r\n    // str1 -> lower bound\r\n    // str2 -> upper bound\r\n\r\n    N = str2.size();\r\n\r\n    reverse(all(str1));\r\n    reverse(all(str2));\r\n\r\n    while (str1.size() < str2.size())\r\n    {\r\n        str1.push_back('0');\r\n    }\r\n\r\n    memset(dp, -1, sizeof(dp));\r\n    cout << digitDP(N - 1) << endl;\r\n}"
    ],
    "description": "digitDP2Flags"
  },
  "digitDP1Flags": {
    "prefix": "digitDP1Flags",
    "body": [
      "string str;\r\nll dp[10][2][82];\r\nint N;\r\n\r\nll digitDP(int pos = 0, int flag = 1, ll res = 0)\r\n{\r\n    if (pos == N)\r\n        return res;\r\n    else if (dp[pos][flag][res] != -1)\r\n        return dp[pos][flag][res];\r\n    else\r\n    {\r\n        ll ans = 0;\r\n        int ub = flag ? (str[pos] - '0') : 9;\r\n\r\n        REP(i, 0, ub)\r\n        {\r\n            ans += digitDP(pos + 1, (i == ub & flag), res + i);\r\n        }\r\n\r\n        return dp[pos][flag][res] = ans;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll ans = 0;\r\n    cin >> str;\r\n    N = str.size();\r\n    ans -= digitDP();\r\n\r\n    cin >> str;\r\n    N = str.size();\r\n    ans += digitDP();\r\n}"
    ],
    "description": "digitDP1Flags"
  },
  "digitDPOptimized": {
    "prefix": "digitDPOptimized",
    "body": [
      "string str1;\r\nstring str2;\r\nll dp[19][18];\r\nint N;\r\n\r\nll digitDP(int pos, int flag1 = 1, int flag2 = 1, int val=0)\r\n{\r\n    if (pos == -1)\r\n        return val==0;\r\n\r\n    ll &res = dp[pos][val];\r\n\r\n    if (flag1 == 0 && flag2 == 0 && res != -1)\r\n        return res;\r\n\r\n    ll ans = 0;\r\n    \r\n    int lb = flag1 ? (str1[pos] - '0') : 0;\r\n    int ub = flag2 ? (str2[pos] - '0') : 9;\r\n\r\n    REP(i, lb, ub)\r\n    {\r\n        ans += digitDP(pos - 1, (i==lb && flag1), (i == ub & flag2), val+i);\r\n    }\r\n\r\n    return flag1==0 && flag2==0 ? res = ans: ans;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    cin >> str1 >> str2;\r\n\r\n    reverse(all(str1));\r\n    reverse(all(str2));\r\n\r\n    while (str1.size() < str2.size())\r\n    {\r\n        str1.push_back('0');\r\n    }\r\n\r\n    N = str1.size();\r\n    ll ans = digitDP(N - 1);\r\n    cout << ans << endl;\r\n}\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\r\n    // freopen(\"input.txt\",\"r\",stdin);\r\n    // freopen(\"output.txt\",\"w\",stdout);\r\n\r\n    memset(dp, -1, sizeof(dp));\r\n\r\n    int t = 1;\r\n    cin >> t;\r\n\r\n    REP(tc, 1, t)\r\n    {\r\n        // cout<<\"Case \"<<tc<<\":\"<<endl;\r\n        solve();\r\n    }\r\n\r\n    return 0;\r\n}"
    ],
    "description": "digitDPOptimized"
  },
  "digitDPUsingHighAndLow": {
    "prefix": "digitDPUsingHighAndLow",
    "body": [
      "string str;\r\nint N;\r\nll dp[19][20][20][20];\r\n\r\nll digitDp(int pos, int left_lo, int left_hi, int zeros=0)\r\n{\r\n    if(pos>(N-1-pos+zeros))\r\n    {\r\n        return left_lo<=left_hi;\r\n    }\r\n\r\n    if(dp[pos][left_lo][left_hi][zeros]!=-1)\r\n        return dp[pos][left_lo][left_hi][zeros];\r\n\r\n    ll ans = 0;\r\n\r\n    REP(i,0,9)\r\n    {\r\n        int nlo = left_lo;\r\n        int nhi = left_hi;\r\n\r\n        if(i < (str[pos]-'0') && pos < nlo)nlo=pos;\r\n        if(i < (str[N-1-pos+zeros]-'0') && N-1-pos+zeros<nlo)nlo=N-1-pos+zeros;\r\n        if(i > (str[pos]-'0') && pos < nhi)nhi=pos;\r\n        if(i > (str[N-1-pos+zeros]-'0') && N-1-pos+zeros < nhi)nhi=N-1-pos+zeros;\r\n\r\n        ans += digitDp(pos+1,nlo,nhi,zeros + (zeros==pos && i==0));\r\n    }\r\n\r\n    return dp[pos][left_lo][left_hi][zeros] = ans;\r\n}\r\n\r\nint check(string &s)\r\n{\r\n    int i = 0, j = s.size()-1;\r\n\r\n    while (i < j)\r\n    {\r\n        if(s[i]!=s[j])\r\n            return 0;\r\n        i++,j--;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll ans = 0;\r\n    cin>>str;\r\n    N = str.size();\r\n    memset(dp,-1,sizeof(dp));\r\n    ans-=digitDp(0,N+1,N+1,0);\r\n    ans+=check(str);\r\n    \r\n    cin>>str;\r\n    N = str.size();\r\n    memset(dp,-1,sizeof(dp));\r\n    ans+=digitDp(0,N+1,N+1,0);\r\n    \r\n    cout<<ans<<endl;\r\n}"
    ],
    "description": "digitDPUsingHighAndLow"
  },
  "binExp": {
    "prefix": "binExp",
    "body": [
      "ll binExp(ll a, ll p, ll m = mod)\r\n{\r\n\tll res = 1;\r\n\r\n\twhile (p)\r\n\t{\r\n\t\tif (p & 1)\r\n\t\t\tres = (res * a) % m;\r\n\t\ta = (a * a) % m;\r\n\t\tp >>= 1;\r\n\t}\r\n\r\n\treturn res;\r\n}"
    ],
    "description": "binExp"
  },
  "mulmod": {
    "prefix": "mulmod",
    "body": [
      "ll mulmod(ll a, ll b, ll c)\r\n{\r\n\tll x = 0, y = a % c;\r\n\t\r\n\twhile (b > 0)\r\n\t{\r\n\t\tif (b % 2 == 1)\r\n\t\t{\r\n\t\t\tx = (x + y) % c;\r\n\t\t}\r\n\t\ty = (y * 2LL) % c;\r\n\t\tb /= 2;\r\n\t}\r\n\r\n\treturn x % c;\r\n}"
    ],
    "description": "mulmod"
  }
}

